[{"content":"Se você é como eu e utiliza vários ambientes de trabalho, como máquinas virtuais, servidores, mais de um sistema operacional, etc\u0026hellip;, é sempre útil manter uma lista de aplicações para te ajudar a agilizar o processo de preparação do ambiente.\nEste é o meu setup, separado por categorias, com as minhas opções padrão e observações.\nSDKs São os kits de desenvolvimento, providos pelos próprios proprietários:\n.NET core - A versão multiplataforma pra desenvolvimento em C#, livre e de código aberto da Microsoft. Node.js - O runtime de javascript mais popular do mundo, construído com o motor V8 do Chrome. Java - O JDK é kit de desenvolvimento, utilizado para apicações Web, Mobile e Desktop em java. Editores de texto Aplicações utilitárias e leves para edição avançada de arquivos de texto:\nVisual Studio Code - Editor gratuito e de código aberto da Microsoft, que vêm se tornando o editor padrão para a maioria das linguagens. Notepad++ - Como o editor de texto padrão do Windows (Bloco de Notas) é extremamente simplista e limitado, para mim, o Notepad++ se torna uma opção indispensável para o sistema operacional. IDEs Os ambientes de desenvolvimento integrado (integrated development environment), são as aplicações mais robustas para desenvolvimento de software, contendo vários facilitadores para escrita, análise de código, correção de falhas, testes, entre outros.\nVisual Studio - A ferramenta principal da Microsoft oferece uma excelente experiência para os desenvolvedores. MonoDevelop - Grande experiência no sistema operacional Linux e alta compatibilidade com soluções produzidas no Visual Studio. JetBrains Rider - IDE multiplataforma, combinando a base do IntelliJ com o poder do ReSharper. JetBrains IntelliJ - Ferramenta mais inteligente e produtiva para desenvolvimento em Java. Android Studio - A escolha padrão para desenvolvimento nativo de aplicativos para Android. SGBDs Aplicações amigáveis para gerenciamento de banco de dados:\nSQL Server Managment Studio - Nível empresarial para gerenciamento de bancos de dados da Microsoft (MSSQL). Azure Data Studio - Um VsCode modificado para bancos de dados da microsoft. PgAdmin 3 - PgAdmin é a ferramenta de gerenciamento de bancos PostgreSQL mais popular do mercado. Coloquei a versão 3 porque a 4 ainda não me agrada completamente, mas com certeza no futuro irá. Robo 3T - Simples, gratuita e competente no gerenciamento de coleções de dados do MongoDB. LINQ Pad - Apesar de possuir inúmeras outras utilidades, esta ferramenta me ajuda no desenvolvimento de aplicações com banco de dados SQLCe. update:\nValentina Studio - Esta ferramenta me surpreendeu pela sua qualidade e compatibilidade, e foi a que me ofereceu a melhor experiência no Linux. Chat Aplicações para comunicação:\nSlack - A ferramenta líder em comunicação de times. Pidgin - Com a finalidade de utilizar o protocolo XMPP. VCS Clientes para sistemas de controle de versão:\nGit - Gerenciamento distribuído de repositórios. Subversion - Gerenciamento centralizado de repositórios. Outras Outras aplicações úteis:\nInkscape - Ferramenta gratuita incrível para criação de vetores. Gimp - Outra ferramenta gratuita e incrível, para edição de imagens. Meld - Comparação entre arquivos de maneira simples e efetiva. Libre Office - Pacote de aplicações de escritório extremamente competentes e gratuitas. Postman - Cliente para testes de Apis bem performático e intuitivo. VirtualBox - Gerenciador de máquinas virtuais gratuito e multiplataforma. GNU Win32 - Ferramentas da linha de comando GNU para Windows. WinSCP - Cliente SFTP, SCP, S3 e FTP para Windows. Remmina - Excelente cliente de acesso remoto à Desktops, gratuito e open source. Conclusão Este é o meu setup inicial feito com o intuito de preparar uma máquina para desenvolvimento. A maioria das ferramentas listadas são gratuitas e multiplataforma, o que me permite trabalhar de forme uniforme em basicamente qualquer sistema operacional.\n","date":"2018-01-26T13:13:13Z","permalink":"https://joaolucasgtr.github.io/posts/2018/01/26/checklist-ambiente/","title":"Checklist Ambiente"},{"content":"Dias atrás, uma notícia muito séria foi divulgada sobre má utilização de software proprietário: A universidade Cândido Mendes, do Rio de Janeiro, vai ter sua sede leiloada pela Justiça para quitar uma dívida adquirida após ter perdido um processo milionário para a Microsoft, por utilização de versões piratas do Windows. Triste.\nEmbora exista uma parcela da população que ainda não saiba, o Windows é um software privado e você precisa comprar sua licença de uso. Caso não adquira uma, você não poderá utilizar todos os recursos do sistema, terá atrasos no recebimento de atualizações de segurança e será notificado todo dia sobre a necessidade de ativação, entre outros.\nA boa notícia Provavelmente, você como empresário não deseja ser multado por utilização indevida de software proprietário também, ou, como um funcionário comprometido, não deseja que sua empresa empregadora passe por tal situação, certo?\nA boa notícia é que existe uma alternativa gratuita, capaz de atender a maioria absoluta das demandas empresariais de software e com desempenho e confiabilidades excelentes: o sistema operacional do pinguim, Linux.\nPrincipais vantagens para você implementar a utilização de Linux no seu ambiente de trabalho:\nRedução de custo desnecessário Não existe disputa neste quesito. Com Linux você não precisará se preocupar com problemas de fiscalização e compras de licenças comerciais, visto que é um sistema operacional completo distribuído de forma gratuita e possui código aberto. Saiba que todos os computadores da sua empresa necessitam de licenças originais para funcionamento, inclusive aquelas máquinas sub-utilizadas.\nDesempenho em hardware antigo Ainda falando sobre aquelas máquinas sub-utilizadas, provavelmente possuem hardware mais antigo ou menor poder de processamento. Se este for o caso, instalar o Windows 10 nela não será uma boa opção, visto que os requisitos para sua execução de forma satisfatória são altos.\nPor outro lado, algumas distribuições de Linux são focadas em Hardware menos potentes. Ainda assim, mesmo as distribuições mais potentes possuem requisitos menos exigentes que seu rival da Microsoft.\nVersões mais antigas de Windows, como Windows 7 ou Windows XP, irão funcionar bem, porém não receberão atualizações de segurança. Pensando de forma empresarial, esta nem pode ser considerada uma opção.\nResta-lhe duas opções: migrar para Linux ou gastar mais dinheiro comprando mais computadores e licenças de Windows 10.\nSegurança Devido sua adoção massiva, o Windows possui fatia de mercado superior à soma de todos seus concorrentes. Apesar de ser um dado extremamente positivo para a Microsoft, isto faz com que seja o sistema mais visado por usuários mal-intencionados, visando encontrar falhas no sistema para extrair dados sensíveis.\nJá no mundo Linux, a maioria de usuários nem sequer utiliza programas anti-virus, já que o código aberto do sistema garante que correções de segurança sejam mais frequentes e possíveis de ser aplicados por uma quantidade muito maior de desenvolvedores do que os da Microsoft.\nOutro fator importante para garantir a segurança de seu Linux é utilizar as lojas de softwares e repositórios oficiais para instalação de aplicativos. Você pode obter aplicativos direto da loja de forma similar à feita em smartphones, sem comprometer o sistema.\nSoftwares Como o Windows é o campeão em popularidade ao redor do mundo, isto reflete a quantidade de software disponível para instalação. No quesito jogos, o sistema possui uma gama muito maior de opções que os concorrentes e até desempenho melhor, visto que a integração das empresas de Hardware são feitas com o Windows em vista.\nPorém, o ambiente empresarial é diferente e muito menos exigente. É bem provável que você encontre alternativas grátis e compatíveis com Linux para as principais categorias de software, como: suítes de escritório, editores de texto, editores de imagens, editores de vídeo, gerenciadores de e-mail, aplicativos de calendários, entre outros.\nApesar da alta compatibilidade, isto pode ser irrelevante se seu ambiente funciona fortemente em relação com a nuvem. Isto porque todos os principais navegadores são compatíveis com qualquer sistema operacional.\nDica: O site AlternativeTo oferece uma busca extremamente simplificada por softwares similares ao solicitado, com resultados categorizados pela comunidade.\nVisual Usuários de Windows e MacOS são obrigados a concordarem com todas as decisões de design tomadas por seus fabricantes. No caso do MacOs, todas as interfaces do sistema funcionam de forma coesa e padronizada, porém no sistema da Microsoft a situação é diferente, tendo aplicações com visual do Windows 2000, Aero, Windows XP, Windows 10, etc.\nO Linux oferece um catálogo extenso de ambientes gráficos para todos os gostos, sendo possível customizar até os mínimos detalhes. Ainda assim, existem ambientes focados em usuários finais, com filosofia minimalista e que oferecem uma experiência bem satisfatória sem precisar de configurações. Sugestões interessantes: elementaryOs, deepinOs e zorinOs.\nConclusão Este artigo não visa menosprezar um sistema sobre o outro, mas sim oferecer um novo ponto de vista racional sobre o assunto. Pensando de forma empreendedora, qualquer custo desnecessário deve ser avaliado, ainda mais se houverem mais benefícios embutidos.\nReferência Artigo Tecmundo sobre universidade Cândido Mendes ","date":"2017-09-03T20:39:33Z","permalink":"https://joaolucasgtr.github.io/posts/2017/09/03/por-que-utilizar-linux-na-sua-empresa/","title":"Por que utilizar Linux na sua empresa?"},{"content":"Como a grande maioria das IDEs e Editores de código já possuem ferramentas gráficas para gerenciar o versionamento de código, você pode acabar se acomodando à esses recursos simplificados e não se preocupar em aprender outras maneiras de fazê-lo.\nPode ser que você se veja numa situação onde a sua ferramenta favorita não esteja disponível (como numa prova, por exemplo) ou em outra onde a única ferramenta disponível para manipulação do sistema operacional seja o tão temido Terminal.\nCom o domínio absoluto de sistemas operacionais baseados em Linux no mercado de servidores*, é bem provável que você passe por algo parecido um dia, caso não tenha ainda.\nSendo assim, separei alguns comandos essenciais para o fluxo de trabalho do dia a dia, agrupados por estágio de utilização para facilitar o entendimento.\n* fonte\nConfiguração Configurações iniciais:\ngit config --global user.name \u0026quot;John Doe\u0026quot; - denifir nome global do usuário. git config --global user.email \u0026quot;john_doe@gitlab.com\u0026quot; - definir email global do usuário. Início Duas maneiras simples para iniciar um repositório git local em seu HD:\ngit clone [url do repositório] - caso o repositório já exista no servidor remoto e você quer criar um repositório local exatamente igual ao remoto\ngit init - caso você queira transformar a pasta atual em um repositório git. Após a criação, é necessário adicionar o endereço do servidor remoto para que possa enviar ao servidor as alterações realizadas localmente: git remote add origin [url do repositório].\nFeito isso, você já está pronto para utilizar o versionamento de forma local.\nBranches Após o passo anterior, você automaticamente estará trabalhando na branch master, o que pode não ser considerado uma boa prática por parte da equipe. Geralmente você vai querer criar uma branch para desenvolvimento e, depois das implementações concluídas, aplicá-las à branch master como conclusão de suas tarefas.\ngit checkout -b [nome da branch] - cria a branch localmente e já altera a cópia de trabalho atual.\ngit push -u - envia as alterações locais para o servidor remoto, já criando uma branch com o mesmo nome da local.\nGerenciamento Comandos utilizados com maior frequência, após as fases de configuração anteriores:\ngit pull - sincroniza a versão local com as alterações persistidas no servidor remoto, enviadas desde a última vez que este comando foi executado. O servidor irá bloquear suas alterações caso a sua versão local esteja desatualizada.\ngit add [arquivo ou caminho] - coloca o arquivo, ou arquivos no caminho, na fila para o próximo envio de dados ao servidor.\ngit status - exibe um relatório de alterações realizadas localmente para conferência.\ngit reset HEAD [arquivo] - caso mude de ideia sobre alguma alteração na fila de envios, utilize este comando para descartar as alterações, removendo assim o arquivo da fila de envio.\ngit commit -m \u0026quot;[mensagem]\u0026quot; - aplica as alterações que estavam na fila até então no seu servidor local.\ngit push - envia para o servidor remoto o pacote de atualizações produzido localmente na sua máquina, desde a última sincronização.\nAnalisando alterações Para consultar o histórico de alterações, utilize o comando:\ngit log - abre uma lista descritiva sobre os commits realizados até então. É possível aplicar diversas opções de filtro, como por exemplo:\ngit log --max-count=5 - para exibir os últimos cinco\ngit log --author=John Doe - para exibir somente commits enviados pelo usuário \u0026ldquo;John Doe\u0026rdquo;\ngit log --stat - para ver estatísticas de alteração em cada commit\ngit log --since=2.weeks - commits das últimas duas semanas\n.gitignore Para ignorar alterações em arquivos e pastas de maneira automática no repositório, é preciso criar o arquivo .gitignore, que nada mais é que um arquivo de texto, sem extensão, onde você irá definir em cada linha o que deverá ser ignorado pelo versionamento.\nAs definições escritas podem ser arquivos, pastas, subpastas, arquivos de uma determinada extensão, etc\u0026hellip;\nReferência completa: git .gitignore ","date":"2017-06-15T19:34:43Z","permalink":"https://joaolucasgtr.github.io/posts/2017/06/15/introdu%C3%A7%C3%A3o-ao-git/","title":"Introdução ao Git"},{"content":"O padrão DAO (Data access object) fornece uma interface abstrata de comunicação com o banco de dados, ou qualquer outro mecanismo de persistẽncia de dados. Mapeando todas as chamadas da aplicação para a camada de persistência, classes DAO proverão operações de dados específicas sem expor o banco de dados em si. Este isolamento, respeita o princípio de responsabilidade única.\nVantagens A principal vantagem na utilização do padrão é a clara separação entre partes do código que não deveriam conhecer uma a outra. Todos os detalhes de implementação da comunicação entre a aplicação e o banco de dados ficam encapsuladas de forma que as demais partes do código não possuam acesso.\nSendo assim, alterações na persistẽncia de uma entidade pode ser aplicadas em apenas um lugar do código.\nAo implementar o DAO como um intermediário entre a aplicação e o mecanismo de armazenamento, ganhamos a possibilidade de alterar completamente a tecnologia de persistência sem requerer muito esforço na camada de código da aplicação.\nDesvantagens Possíveis desvantagens ao implementar o padrão são:\nLeaky Abstractions - Abstrações imperfeitas geradas devido ao aumento na complexidade das regras de negócio; Código duplicado - Ao duplicar operações de CRUD em classes distintas Inversão de abstração - Ao precisar reescrever funções já implementadas porém não expostas pelas interfaces para utilização em alto nível. Como funciona A implementação “clássica” do padrão DAO, exige que tenhamos uma interface com as operações de banco de dados, a classe implementadora da interface e uma classe de domínio que represente o modelo (ou entidade do banco de dados).\nNo exemplo, vamos usar o padrão para demonstrar operações com a entidade Customer.\nModelo:\n1 2 3 4 5 6 7 8 9 10 public class Customer implements java.io.Serializable { int CustomerNumber; String name; String streetAddress; String city; ... /* getters e setters... */ ... } Interface de operações:\n1 2 3 4 5 6 7 8 public interface CustomerDAO { public int insertCustomer(...); public boolean deleteCustomer(...); public Customer findCustomer(...); public boolean updateCustomer(...); public Collection selectCustomersTO(...); ... } Classe implementadora:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /* Classe que se comunica com o banco de dados Postgres: */ public class CustomerPgDAO implements CustomerDAO { public CloudscapeCustomerDAO() { /* inicialização... */ } public int insertCustomer(...) { /* lógica de inserção... */ /* retorna o novo id criado ou -1 em caso de erro. */ } public boolean deleteCustomer(...) { /* lógica de deleção... */ /* retorna um boolean dizendo se a operação foi bem sucedida. */ } public Customer findCustomer(...) { /* lógica para consulta de um registro da entidade Customer... */ /* retorna uma instância da classe Customer ou nulo. */ } public boolean updateCustomer(...) { /* lógica para atualizar um registro... */ /* retorna um boolean dizendo se a operação foi bem sucedida. */ } public Collection selectCustomersTO(...) { /* lógica para listar os registros de Customer... */ } ... } Código para consumir este DAO\nEm outras partes da aplicação, onde você irá precisar interagir com as classes do padrão, você irá precisar de algo como:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /* criando instância da classe: */ CustomerDAO dao = new CustomerPgDAO(); /* criando um novo Customer: */ int newCustomer = dao.insertCustomer(...); /* procurando algum Customer específico: */ Customer customer = dao.findCustomer(...); /* modificando os valores do Customer obtido: */ customer.setAddress(...); customer.setEmail(...); /* aplicando a persistência através do DAO: */ dao.updateCustomer(customer); /* excluir um Customer da persistência: */ dao.deleteCustomer(...); ... Neste exemplo estamos lidando com persistência no banco de dados Postgresql, mas caso seja necessário adicionar suporte a outro banco de dados, basta criar uma nova classe implementadora da interface CustomerDAO, como foi feito em CustomerPgDAO, porém com a lógica de comunicação compatível com o novo banco de dados, como MongoDB por exemplo.\nDo ponto de vista da camada de negócio, não será necessária nenhuma alteração!\nVale ressaltar também que pode ser utilizado o padrão de projeto Factory Method para encapsular a definição e criação de instâncias implementadoras da interface CustomerDAO, diminuindo ainda mais o nível de acoplamento no código.\nConclusão Apesar de existirem diversas ferramentas que já fazem o trabalho pesado para o desenvolvedor, é muito válido conhecer o padrão e os problemas que ele se propõe a resolver. Compreender os conceitos por trás das abstrações já existentes pode ser uma forma de aprimorar suas habilidades de programação, fornecendo maior compreensão sobre um problema e sua solução.\nReferências Data Access Object on Wikipedia Oracle\u0026rsquo;s Core J2EE Patterns ","date":"2017-03-20T20:18:07Z","permalink":"https://joaolucasgtr.github.io/posts/2017/03/20/o-padr%C3%A3o-dao/","title":"O padrão DAO"},{"content":"O termo SOA representa as iniciais de Service Oriented Architecture (arquitetura orientada a serviços), e representa um estilo arquitetural onde recursos da aplicação são disponibilizados por meio de serviços, através de um protocolo de comunicação pela rede.\nServiços Serviço é uma unidade de funcionalidade que pode ser acessado de forma remota ou local, e de forma independente. Um serviço possui quatro propriedades:\nRepresenta uma atividade de negócio com uma resposta definida É self-contained (independente) É uma caixa preta para seus consumidores, já que não possuem conhecimento de como o serviço funciona por dentro Pode consistir de outros serviços de camadas inferiores Arquitetura orientada a serviços permite a integração entre sistemas distribuídos, mantidos e publicados de forma completamente separada. Está relacionada à ideia de API (application programming interface), um contrato de comunicação bem definido, que visa simplificar a integração entre softwares.\nConceitos Um manifesto foi publicado em outubro de 2009, onde são descritos seis valores listados a seguir:\nValor de negócio tem mais importância do que à estratégia técnica; Metas estratégicas têm mais importância que benefícios específicos do projeto; Interoperabilidade intrínseca tem mais importância do que a integração personalizada; Serviços compartilhados têm mais importância que as implementações específicas; Flexibilidade tem mais importância que otimização; Refinamento evolutivo tem mais importância do que a busca pela perfeição inicial. Princípios Apesar de não existirem padrões industriais que definem exatamente a composição de arquitetura orientada a serviços, alguns princípios foram criados.\nOs mais comuns são:\nAutonomia de referência de serviços\nO relacionamento entre serviços é minimizado até o nível de que só conhecem a existência uns dos outros.\nTransparẽncia de localização de serviços\nServiços podem ser chamados de qualquer local dentro da rede que estão contidos.\nAbstração de serviços\nServiços agem como uma caixa preta, ou seja, a lógica interna fica escondida dos consumidores.\nAutonomia de serviços\nServiços são independentes e controlam toda a funcionalidade que encapsulam.\nFalta de estado de serviços (Stateless)\nServiços não armazenam estado, somente retornam o valor requisitado ou lançam alguma exceção, minimizando o consumo de recursos.\nGranularidade de serviços\nEste princípio diz que serviços devem possuir um tamanho adequado. Sua funcionalidade deve ser relevante.\nNormalidade de serviços\nServiços são normalizados (como tabelas em banco de dados) para minimizar a possibilidade de redundância.\nReusabilidade de serviços\nA lógica é dividida em vários serviços, para promover o reuso do código.\n\u0026hellip;entre outros.\nImplementações A arquitetura em questão é implementada através de web services ou microserviços. Estes representam os blocos de funcionalidades acessíveis através de protocolos de comunicação de rede, que são independentes de plataforma ou linguagem de programação.\nSendo assim, sistemas podem operar de forma independente e dinâmica, utilizando diversas tecnologias como:\nWeb services baseados em WSDL e SOAP Messaging, com ActiveMQ, JMS, RabbitMQ REST over HTTP WCF (Windows Communication Foundation) gRPC Conclusão Como vimos, a arquitetura orientada a serviços reforça vários conceitos de boas práticas, como reuso, modularidade, separação de responsabilidade, entre outros. Além disso, fatores como escalabilidade, flexibilidade e alta disponibilidade a transformam numa opção muito atrativa para o ambiente corporativo, devido à simplicidade na adoção e manutenção por parte das equipes de desenvolvimento.\nReferências Service-oriented architecture on Wikipedia SOA Manifesto ","date":"2017-03-20T20:18:07Z","permalink":"https://joaolucasgtr.github.io/posts/2017/03/20/soa-service-oriented-architecture/","title":"SOA - Service Oriented Architecture"},{"content":"Após mencionar o acrônimo SOLID na publicação sobre Princípios importantes, resolvi escrever um artigo mais detalhado para abordar cada conceito de forma particular e com exemplos. Assim fica mais fácil compreender e absorver o valioso conteúdo presente nos conceitos.\nS - Single Responsibility Principle (SRP) O princípio da responsabilidade única é um conceito que diz que cada módulo ou classe deveria possuir apenas responsabilidade sobre uma parte da funcionalidade de um software, e que essa responsabilidade deveria ser encapsulada pela classe, módulo ou função.\nRobert C. Martin expressa o princípio como:\n\u0026ldquo;A class should have only one reason to change.\u0026rdquo; (Uma classe deveria ter apenas um motivo para mudar.)\nObjetivo O objetivo aqui é evitar a criação de uma God class (ou God object), as classes \u0026ldquo;Deusas\u0026rdquo; que possuem diversas responsabilidades e funções muito além do que deveriam ser o seu escopo.\nExemplo 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Employee { public int Employee_Id { get; set; } public string Employee_Name { get; set; } public bool InsertIntoEmployeeTable(Employee em) { /* Insert into employee table. */ return true; } public void GenerateReport(Employee em) { /* Report generation with employee data using crystal report. */ } } Esta classe viola o SRP ao ser responsável por duas operações distintas:\nLidar com operações de banco de dados; Lidar com a operação de gerar relatórios sobre um empregado. De acordo com o SRP, o ideal seria criar duas classes, com responsabilidades mais coerentes, da seguinte forma:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class Employee { public int Employee_Id { get; set; } public string Employee_Name { get; set; } public bool InsertIntoEmployeeTable(Employee em) { /* Insert into employee table. */ return true; } } public class Reporter { public void GenerateReport(Employee em) { /* Report generation with employee data using crystal report. */ } } Assim, alterações na geração de relatórios não irão requerer mudanças na classe Employee, e vice-versa.\nO - Open closed principle (OCP) O princípio aberto / fechado diz que entidades do software (classes, módulos, funções, etc.) devem estar abertas para extensão, porém fechadas para alteração, assim uma entidade irá permitir que seu comportamento seja estendido sem modificar seu código original.\nObjetivo Aumentar o nível de desacoplamento e segurança, evitando que alterações sejam feitas posteriormente em classes já presentes nos sistemas.\nExemplo 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Reporter { public string ReportType { get; set; } public void GenerateReport(Employee em) { if (ReportType == \u0026#34;CRS\u0026#34;) { /* Report generation with employee data in Crystal Report. */ } if (ReportType == \u0026#34;PDF\u0026#34;) { /* Report generation with employee data in PDF. */ } } } Esta classe claramente viola o OCP, pois uma vez que seja recebido um requisito para geração de relatório em outro formato, csv por exemplo, deveríamos obrigatoriamente ter que alterá-la para incluir mais uma condição no método.\nAplicando o OCP, poderíamos criar uma interface e delegar a lógica de geração de relatórios somente para os implementadores. Com isto, incluir um novo tipo de relatório consiste apenas em criar uma nova classe implementadora de interface, sem gerar alterações na classe anterior.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public class IReportGenerator { public virtual void GenerateReport() { /* From base */ } } public class CrystalReportGenerator : IReportGenerator { public override void GenerateReport() { /* Generate crystal report. */ } } public class PDFReportGenerator : IReportGenerator { public override void GenerateReport() { /* Generate PDF report. */ } } public class Reporter { public void GenerateReport(IReportGenerator generator) { generator.GenerateReport(); } } L - Liskov substitution principle (LSP) O princípio da substituição de Liskov diz que a substituição de uma classe derivada por sua classe base não deve afetar o comportamento correto do sistema.\nObjetivo Manter a coesão entre as abstrações do código, evitando extensões de interfaces desnecessárias.\nExemplo 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 public class Employee { public string GetName() { return \u0026#34;Base name\u0026#34;; } } public class CasualEmployee : Employee { public override string GetName() { return \u0026#34;My name is CasualEmployee\u0026#34;; } } public class ContractualEmployee : Employee { public override string GetName() { return \u0026#34;My name is ContractualEmployee\u0026#34;; } } public static void Main(string[] args) { var employees = new List\u0026lt;Employee\u0026gt; { new Employee(), new CasualEmployee(), new ContractualEmployee() }; foreach (var e in employees) Console.WriteLine(e.GetName()); } As classes derivadas de Employee, neste exemplo, podem ser substituídas pela classe base sem gerar efeitos indesejados no código, pois não há violação do LSP.\nEste princípio está altamente ligado ao próximo tópico da lista, por se tratar de escrever abstrações de forma mais coesa.\nI - Interface segregation principle (ISP) O princípio da segregação de interfaces diz que uma classe não deve implementar métodos de uma interface que ele não irá usar.\nObjetivo Optar pela criação de várias interfaces específicas sobre uma interface generalista, evitando obrigar que classes implementem métodos irrelevantes para si mesmas.\nExemplo 1 2 3 4 5 interface IEmployee { string GetName(); int GetContractId(); } Se inserirmos o método GetContractId na interface Employee estaremos violando o princípio ISP pois somente empregados do tipo ContractualEmployee possuirão um número de contrato. A classe CasualEmployee irá ser forçada a implementar um método que ela nunca utilizará. Sendo assim, o ideal seria:\n1 2 3 4 5 6 7 8 9 10 11 12 13 interface IEmployee { string GetName(); } interface IContractualEmployee : IEmployee { int GetContractId(); } public class ContractualEmployee : IContractualEmployee { } public class CasualEmployee : IEmployee { } D - Dependency inversion principle (DIP) O princípio da inversão de dependência é uma forma poderosa de desacoplamento de código. Nele é dito que classes não devem dependender de implementações, mas sim de abstrações:\nMódulos de alto nível não deveriam depender de módulos de baixo nível. Ambos deveriam depender de abstrações (interfaces). Abstrações não deveriam depender de detalhes. Detalhes (implementação concreta) deveriam depender de abstrações.\nObjetivo O objetivo principal do DIP é reforçar o desacoplamento, evitando que classes possuam dependências fortes com outras classes.\nExemplo Imagine que vamos precisar enviar notificações para usuários após alterações realizadas no banco de dados.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class Email { public void SendMail() { } } public class Notification { private Email _email; public Notification() { _email = new Email(); } public void PromotionalNotification() { _email.SendMail(); } } Assim a classe Notification depende completamente da classe Email. Em qualquer lugar que for necessário o envio de notificações, será necessário também a inclusão da classe Email. O forte acoplamento dificulta também a inclusão de outros métodos de notificação.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 interface INotifier { void SendNotification(); } public class Email : INotifier { public void SendNotification() { /* send email notification */ } } public class SMS : INotifier { public void SendNotification() { /* send sms notification */ } } public class Notification { private INotifier _notifier; public Notification(Type notifierType) { if (typeof(notifierType) == typeof(Email)) _notifier = new Email(); if (typeof(notifierType) == typeof(SMS)) _notifier = new SMS(); } public void Notify() { _notifier.SendNotification(); } } Assim está um pouco melhor, porém o objetivo ainda não foi alcançado pois a classe Notification ainda depende das classes implementadoras da interface INotify. Para aplicar o desacoplamento total devemos utilizar a técnica de injeção de dependência, que pode ser feita de três formas:\nConstrutor: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class Notification { private INotifier _notifier; public Notification(INotifier notifier) { _notifier = notifier; } public void Notify() { _notifier.SendNotification(); } } Propriedade: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Notification { private INotifier _notifier; public INotifier Notifier { private get; set { _notifier = value; } } public void Notify() { _notifier.SendNotification(); } } Método: 1 2 3 4 5 6 7 public class Notification { public void Notify(INotifier notifier) { notifier.SendNotification(); } } Conclusão Podemos perceber que alguns dos princípios são bem próximos e com um tempo de prática e aplicação, você com certeza irá notar a evolução na qualidade do código que escreve. Aplicar as boas práticas pode não ser do interesse de todos, o que libera espaço para que você se destaque quando os resultados começarem a aparecer.\nReferências SOLID on Wikipedia SOLID Principle with C# Example ","date":"2017-02-20T23:56:22Z","permalink":"https://joaolucasgtr.github.io/posts/2017/02/20/solid-com-exemplos/","title":"SOLID (com exemplos)"},{"content":"O termo \u0026ldquo;refatorar\u0026rdquo; diz respeito à técnica de reestruturação de um trecho de código existente, modificando a sua estrutura interna sem modificar seu comportamento externo. Apesar de não parecer muito atraente para pessoas da área de gerência, a aplicação contínua desta prática poderá gerar efeitos bastante significativos na agilidade de trabalho do projeto alvo.\nO que é No livro “Refactoring”, escrito por Martin Fowler em 2000, ele define:\nSubstantivo:\n“uma mudança feita na estrutura interna do software para deixá-lo mais fácil de entender e mais barato de modificá-lo, sem alterar seu comportamento observável.”\nVerbo:\nreestruturar um software aplicando uma série de refatorações, sem alterar seu comportamento observável.\nRefatoração não é somente uma nova palavra para “limpar seu código”, pois define uma técnica de aprimoramento da saúde da base de código. Esta técnica consiste em aplicar várias transformações pequenas, com poucas alterações. Após várias dessas transformações em sequência o resultado final certamente será significativo.\nPor que utilizar? As intenções por trás da refatoração são: melhorar o design do código, melhorar a estruturação, reduzir complexidades, aplicar boas práticas, etc.\nA refatoração é geralmente iniciada após a percepção de bad smells, ou seja, funções muito grandes, exagero de condicionais, identificação de códigos similares próximos, entre outros.\nOutro ponto muito importante sobre a refatoração é a diminuição do custo para implementação de melhorias. Quando um software é lançado, existe a necessidade de continuar aprimorando-o constantemente, para correção de bugs e inclusão de novos recursos.\nNuma base de código não saudável, a medida em que novos recursos vão sendo implementados, sem aplicação de refatoração, a velocidade do time de desenvolvimento irá diminuir constantemente. Por isso é importante manter a cultura de refatoração, para evitar o aumento de complexidade desnecessário.\nQuando refatorar? Segundo o livro, a refatoração não deve ser uma tarefa especial lançada no planejamento, mas sim uma prática inserida no dia-a-dia de todos os desenvolvedores. O autor ainda cita dois exemplos sobre o mindset que utiliza para definir quando um código precisa ser refatorado:\nAo adicionar um novo recurso a um sistema\nPrimeiramente, é necessário olhar ao código já existente e se ele está estruturado de um jeito que seja simples incluir essa nova funcionalidade. Se não estiver, geralmente é melhor aplicar refatorações no código antes, para que a inclusão do recurso seja feita de forma simples.\nAssim o tempo total de sua tarefa deverá ser menor do que gastar horas tentando entender um código complexo e que, na próxima vez que um desenvolvedor passar por ele, terá de gastar muito tempo também tentando entendê-lo.\nAo modificar um recurso já existente\nÉ sempre bom vasculhar a base de código já existente antes de começar. Pode ser que você encontre o que precisa em funções já definidas em outras partes do código, sobrando para você apenas o trabalho de chamá-las corretamente e evitar violar o princípio DRY.\nCaso o código que você precise alterar exija bastante esforço para compreensão, então é melhor aplicar refatorações para que outro desenvolvedor não seja exigido novamente por esse código (incluindo seu \u0026ldquo;eu\u0026rdquo; do futuro).\nExemplos A seguir, alguns exemplos de técnicas de refatoração presentes no livro:\nExtract method Problema: Você possui um fragmento de código que pode ser agrupado:\n1 2 3 4 5 6 7 void printOwing() { printBanner(); /* Print details. */ System.out.println(\u0026#34;name: \u0026#34; + name); System.out.println(\u0026#34;amount: \u0026#34; + getOutstanding()); } Solução: Agrupe este trecho em um novo método e chame-o no método antigo:\n1 2 3 4 5 6 7 8 9 void printOwing() { printBanner(); printDetails(getOutstanding()); } void printDetails(double outstanding) { System.out.println(\u0026#34;name: \u0026#34; + name); System.out.println(\u0026#34;amount: \u0026#34; + outstanding); } Esta técnica visa deixar seu código mais legível e reduzir a quantidade de linhas por método no código.\nExtract variable Problema: Você possui uma expressão difícil de entender:\n1 2 3 4 5 6 7 8 void renderBanner() { if ((platform.toUpperCase().indexOf(\u0026#34;MAC\u0026#34;) \u0026gt; -1) \u0026amp;\u0026amp; (browser.toUpperCase().indexOf(\u0026#34;IE\u0026#34;) \u0026gt; -1) \u0026amp;\u0026amp; wasInitialized() \u0026amp;\u0026amp; resize \u0026gt; 0 ) { /* faça algo aqui... */ } } Solução: Atribuir o resultado das expressões a variáveis cujo nome são auto-explicativos:\n1 2 3 4 5 6 7 8 9 void renderBanner() { final boolean isMacOs = platform.toUpperCase().indexOf(\u0026#34;MAC\u0026#34;) \u0026gt; -1; final boolean isIE = browser.toUpperCase().indexOf(\u0026#34;IE\u0026#34;) \u0026gt; -1; final boolean wasResized = resize \u0026gt; 0; if (isMacOs \u0026amp;\u0026amp; isIE \u0026amp;\u0026amp; wasInitialized() \u0026amp;\u0026amp; wasResized) { /* faça algo aqui... */ } } Esta outra técnica também visa aprimorar a legibilidade do código e reduzir a margem de erro ao lidar com múltiplas expressões.\nReplace temp with query Problema: Você criou uma variável temporária para receber o valor de uma expressão:\n1 2 3 4 5 double basePrice = _quantity * _itemPrice; if (basePrice \u0026gt; 1000) return basePrice * 0.95; else return basePrice * 0.98; Solução: Mova a expressão para um método novo e utilize o retorno deste método:\n1 2 3 4 5 6 7 8 if (basePrice() \u0026gt; 1000) return basePrice() * 0.95; else return basePrice() * 0.98; double basePrice() { return _quantity * _itemPrice; } Esta técnica é utilizada para deixar o código mais flexível e preparar o terreno para aplicar a Extract Method posteriormente.\nConsolidate conditional expression Problema: Você possui múltiplas condições que geram o mesmo resultado:\n1 2 3 4 5 6 7 double disabilityAmount() { if (_seniority \u0026lt; 2) return 0; if (_monthsDisabled \u0026gt; 12) return 0; if (_isPartTime) return 0; /* compute the disability amount */ } Solução: Consolide as condicionais em uma expressão única:\n1 2 3 4 5 6 7 8 9 10 11 12 double disabilityAmount() { if (isNotEligibleForDisability()) { return 0; } /* Compute the disability amount. */ } boolean isNotEligableForDisability() { return (_seniority \u0026lt; 2) || _monthsDisabled \u0026gt; 12) || _isPartTime); } Assim você certamente irá evitar (ou até remover) trechos de códigos duplicados e possuir métodos simples para manutenções posteriores.\nDecompose conditional Problema: Você possui uma condicional complexa:\n1 2 3 4 if (date.before (SUMMER_START) || date.after(SUMMER_END)) charge = quantity * _winterRate + _winterServiceCharge; else charge = quantity * _summerRate; Solução: Decomponha as partes complexas em métodos separados: a condição, o trecho executado quando a condição for positiva e o trecho executado quando for negativa:\n1 2 3 4 if (notSummer(date)) charge = winterCharge(quantity); else charge = summerCharge (quantity); Assim é possível dividir lógicas complexas, de forma que seja possível esquecer o que ocorre no else enquanto você estiver ocupado com o que deve ser executado dentro bloco if.\nReplace error code with Exception Problema: Um método retorna um valor específico para indicar erro:\n1 2 3 4 5 6 7 8 int withdraw(int amount) { if (amount \u0026gt; _balance) return -1; else { _balance -= amount; return 0; } } Solução: Lance uma exceção:\n1 2 3 4 5 6 void withdraw(int amount) throws BalanceException { if (amount \u0026gt; _balance) throw new BalanceException(); _balance -= amount; } Lançar códigos de erros é algo obsoleto, herdado de linguagens procedurais. Lançar exceções irá lhe fornecer diagnósticos mais completos sobre as eventuais falhas ocorridas no sistema.\nConclusão Neste artigo pudemos introduzir alguns tópicos sobre o assunto \u0026ldquo;refatoração\u0026rdquo; e exemplificar algumas técnicas básicas. Um mergulho nos materiais originais irá expandir seu repertório de técnicas de escrita de código, que podem ser bem úteis em situações extremas, ou seja, te tornará um desenvolvedor mais seguro e capaz.\nReferências Martin Fowler\u0026rsquo;s Refactoring Code Refactoring on Wikipedia ","date":"2017-02-15T22:53:12Z","permalink":"https://joaolucasgtr.github.io/posts/2017/02/15/refatora%C3%A7%C3%A3o/","title":"Refatoração"},{"content":"Construir um software utilizando a arquitetura em camadas significa desacoplar de forma lógica grupos de rotinas por responsabilidade. Cada camada então deverá possuir apenas uma responsabilidade e gerenciar suas dependências de forma interna. Uma camada superior pode usar os serviços de uma camada inferior, porém o oposto não pode ser aplicado. É importante frisar que para a aplicação desta arquitetura ser bem sucedida, é necessário que o contexto exija a existência desse nível de desacoplamento, ou seja, aplicações de grande escala, onde desacoplamento, boa manutenibilidade e estruturas formais são um requisito básico.\nSobre Uma arquitetura em camadas, geralmente mencionada como n-tier architecture, ou multicamadas, é a forma de estruturar aplicações de forma distribuída. O modelo mais comum de utilização é a arquitetura em três camadas, sendo:\nCamada de apresentação Camada de negócio Camada de dados cujo objetivo claro é obter uma estrutura mais flexível, onde cada camada pode ser facilmente substituída sem a necessidade de refatoração nas demais.\nCamada de apresentação É o nível mais alto da aplicação, onde é possível visualizar e interagir com os dados gerenciados pela aplicação. Geralmente é chamada através de uma GUI (Graphical User Interface, ou interface gráfica de usuário), porém, em diversas aplicações a linha de comando é a camada de apresentação.\nÉ de extrema importância que a única responsabilidade desta camada seja somente exibir os dados obtidos diretamente da camada inferior, a camada de regras de negócio, visando não ferir a premissa de que qualquer camada possa ser facilmente substituída.\nPadrões de projeto A utilização de padrões de projeto apropriados para a camada de apresentação pode reduzir drasticamente o esforço de desenvolvimento do sistema. Além disso, adotar padrões amplamente conhecidos irá melhorar a manutenibilidade e entrada de novos colaboradores ao projeto.\nDecisões mal tomadas nesta camada são, em particular, muito caras e custosas para se resolver, e você pode identificá-las quando:\nAumentar a complexidade das interações do usuário, envolvendo relacionamentos não triviais entre entidades e páginas do sistema; Regras de negócios mudam e você precisa apresentar dados novos ou modificar funcionalidades existentes para novos usuários; Você precisar portar sua aplicação para outras plataformas. Os padrões mais frequentemente utilizados na camada de apresentação são:\nObserver: fornecendo um mecanismo para que um objeto notifique outros de suas alterações, sem estabelecer fortes vínculos de dependências entre eles; Page Controller: utilizado por padrão no ASP.NET, onde cada página irá possuir sua classe controladora (Controller); Model-View-Controller (MVC): para casos de interfaces complexas, onde é necessário o reaproveitamento de dados em locais diferentes de visualização. Camada de negócio A camada de lógica de negócios, ou Business Layer, se refere a implementação de regras de negócio ou requisitos do sistema. Aqui é escrito o código do “mundo real”, que determina como devem ser manipulados os dados da aplicação, como serão aplicadas as regras de validação e serve como camada de ligação entre as camadas de apresentação e dados. É a camada com a maior probabilidade de mudança.\nPadrões de projeto A camada de negócio é que a vai possibilitar o maior número de casos de aplicação de padrões de projeto, por ser a camada “central” da aplicação. Assim, praticamente todos os padrões comportamentais podem ser encaixados nesta camada, basta estudar se é compatível com suas regras de negócio e aplicar.\nOs padrões mais frequentemente utilizados na camada de negócio são:\nFacade: fornecendo uma fachada simplificada que encapsula implementações complexas; Chain of responsibility: organizando a comunicação entre objetos solicitantes e fornecedores sem estabelecer dependência entre eles; Strategy: aprimorando a separação de responsabilidades por meio de abstrações e implementações concretas que não afetam estruturas já prontas; Interpreter: resolvendo expressões através de uma representação hierárquica de objetos; Mediator: encapsulando a maneira como os objetos interagem entre si entre diversos outros\u0026hellip;\nCamada de dados Aqui é escrito todo código responsável por lidar com a persistência dos dados da aplicação, como bancos de dados, sistema de arquivos, etc. É necessário que a camada de dados possua uma API de comunicação que expõe métodos de acesso aos dados e evite totalmente possuir dependência de outras camadas. Isto irá facilitará o processo de substituição da camada de dados quando houver a necessidade de mudança de estrutura para melhorar o desempenho do sistema, por exemplo.\nPadrões de projeto É necessário considerar algumas questões no design da camada de dados que podem afetar diversos aspectos do sistema, como segurança, desempenho e escalabilidade. Deve ser simples também o processo de manutenção e extensão assim que os requisitos começarem a mudar.\nPontos a serem considerados:\nEscolha da tecnologia de persistência: existe realmente a necessidade de se usar um banco de dados? Se sim, esse banco deve ser relacional ou não? Se não, você pode gravar os dados em um arquivo XML ou JSON, ou no formato Chave-Valor? Utilize abstração para diminuir o acoplamento: isto pode ser alcançado utilizando Interfaces, com entradas a saídas bem definidas, ou classes abstratas para compartilhamento de lógicas genéricas; Mantenha toda a lógica da camada de dados na camada de dados! Esta camada deve esconder das outras as rotinas de conexão com banco de dados, criação e execução de queries e conhecimento da tecnologia de persistência; Manipular exceções: somente exceções relacionadas ao acesso a dados devem ser tratadas aqui e propagar para as camadas superiores as demais exceções para tratamento adequado. Padrões mais frequentemente utilizados:\nSingleton: sendo a única fonte de se obter uma conexão ativa com o banco de dados em todo o sistema; Data-Access-Objects (DAO): fornecendo acesso à entidades persistidas de forma isolada segura; Active Record: onde cada entidade de dados é mapeada em uma classe com as operações de CRUD já embutidas; Repository: que fornece uma visão mais orientada a objetos do banco de dados Unit of work: mantendo uma lista de objetos afetados por uma transação para escrita coordenada das alterações. Conclusão Neste artigo, pudemos observar alguns cenários de aplicação da arquitetura em camadas, visando aprimorar a forma como estruturamos sistemas. É possível notar como dois conceitos de boas práticas de programação trabalham muito bem juntos: a arquitetura em camadas e os padrões de projeto. Porém, isto não deve ser considerado como verdade absoluta para todos os casos. A aplicação indevida pode acabar gerando o efeito contrário ao proposto, burocratizando demais o processo de desenvolvimento e manutenção.\nAplique conceitos certos diante de contextos certos.\nReferências: Multitier architecture on wikipedia Design and Implementation Guidelines for Web Clients Design Fundamentals, Chapter 8: Data Layer Guidelines ","date":"2017-02-02T14:18:55Z","permalink":"https://joaolucasgtr.github.io/posts/2017/02/02/arquitetura-em-camadas/","title":"Arquitetura em camadas"},{"content":"A sigla KISS é o acrônimo para “keep it simple, stupid“ ou “keep it stupid simple“. Este princípio visa reduzir casos de Over Engineering, ou excesso de engenharia, tendo foco principal na simplicidade, evitando ao máximo toda complexidade desnecessária.\nCódigo simples é menos passível de bugs, mais fácil de se ler, compreender e aplicar manutenções futuras (até mesmo para você que escreveu a primeira versão).\nEmbora seja amplamente discutida a sua aplicação na área de desenvolvimento de software, a criação do KISS não possui relação direta com a programação, sendo simplesmente a sintetização de um conceito muito mais antigo sobre minimalismo.\nCitações que representam o princípio:\n“Simplicity is the ultimate sophistication.” — Leonardo da Vinci (Simplicidade é a sofisticação suprema)\n“Less is more.” — Mies Van Der Rohe\u0026rsquo;s (Menos é mais)\n\u0026ldquo;It seems that perfection is reached not when there is nothing left to add, but when there is nothing left to take away\u0026rdquo; — Antoine de Saint Exupéry\u0026rsquo;s (A perfeição é alcançada não quando não há mais nada a acrescentar, mas quando não há mais nada a se tirar)\nPorém, manter as coisas simples, ironicamente, não é simples!\nPara aplicar o KISS é preciso pensar de forma abstrata, requer conhecimento e domínio sobre o que você trabalha (linguagem, framework, biblioteca, etc\u0026hellip;), autocrítica, paciência, empatia, entre outros.\nAutocrítica Se você já possui experiência de mercado na área, lidando diariamente com bases de código, é bem provável que você irá perceber que, infelizmente, uma pequena fração desse montante pode ser considerada código simples. Alguns fragmentos podem ser considerados até “anti-padrões”. Eis a questão, o mesmo serve para o seu código, que pode ser perfeitamente compreensível agora, porém experimente visitá-lo após alguns meses\u0026hellip;\nA causa para tanta escrita de código complexo pode não ser somente a falta de habilidades técnicas, mas também pode ser ocasionada por desenvolvedores que gostam de se “exibir”, escrevendo códigos muito complexos para parecem mais inteligentes.\nOutra citação importante:\n\u0026ldquo;Any fool can write code that a computer can understand. Good programmers write code that humans can understand.\u0026rdquo; — Martin Fowler (Qualquer tolo consegue escrever código que um computador entenda. Bons programadores escrevem código que humanos possam entender)\nSe você acha que já escreve códigos simples, aí vai uma dica: sempre há espaço para melhorar.\nMas por que eu deveria aplicar o KISS? Sua aplicação irá te beneficiar das seguintes maneiras:\nVocê irá resolver mais problemas, mais rapidamente; Você irá produzir código para resolver problemas complexos com menos linhas de código; Você irá aumentar a qualidade do código que produz; Será mais fácil construir sistemas grandes, com manutenção facilitada; Sua base de código será mais flexível, mais fácil de estender, modificar ou refatorar quando novos requisitos chegarem; Você poderá trabalhar em grandes grupos de desenvolvimento e grandes projetos, pois todo o código é estupidamente simples. Como aplicar Uma tática simples para aplicação do princípio é sempre quebrar grandes problemas em problemas menores, mais simples e mais compreensíveis. Ao não aplicar este conceito, a tendência é que sejam escritos códigos espaguete, onde existirão muitas condicionais, desvios de fluxo, má estruturação, grande número de variáveis, etc.\nEsse conjunto poderá acabar gerando classes de quinhentas a mil linhas (ou mais) e vários métodos com dezenas e mais dezenas de linhas de código. Claramente violando o princípio KISS.\nOutras maneiras práticas de aplicação podem ser:\nSeja humilde e não se considere um gênio, este é seu primeiro erro. Pense que você não precisará ser pois irá escrever códigos tão simples que ninguém precisará ser um gênio para entender; Quebre grandes problemas em pequenos: cada problema deve ser facilmente resolvido com uma ou duas classes; Mantenha métodos pequenos: limitando apenas uma responsabilidade por método facilitará a escrita de métodos pequenos, até vinte linhas é o cenário ideal. Isto não só irá aprimorar a leitura como também será muito mais fácil encontrar bugs; Mantenha poucas condicionais: quantidades grandes de condicionais em um método podem ser um sintoma de que seu problema ainda não foi quebrado o suficiente; Resolva o problema, então codifique: organizar mentalmente, ou em um rascunho, como resolver um problema irá facilitar o processo de escrita, pois será apenas uma tarefa mecânica de traduzir em código o que você já planejou anteriormente; Não tenha medo de jogar código fora: refatoração é uma prática importante no processo de crescimento e amadurecimento do código. Durante sessões de refatoração você pode aparecer com soluções melhores que as anteriores. Referências Simple Programmer - Why KISS isn\u0026rsquo;t easy The KISS Principle - Apache ","date":"2017-01-08T12:08:33Z","permalink":"https://joaolucasgtr.github.io/posts/2017/01/08/o-princ%C3%ADpio-kiss/","title":"O princípio KISS"},{"content":"Don’t repeat yourself (DRY), ou “Não Se Repita”, é um princípio da área de desenvolvimento que visa reduzir repetição de código, utilizando abstrações e/ou normalização de dados.\nO termo foi difundido no livro The Pragmatic Programmer, por Andy Hunt e Dave Thomas em 1999, e diz que:\nCada bloco de informações deve ter uma representação oficial exclusiva e sem ambiguidades dentro de um sistema.\nQuando o DRY é aplicado com sucesso, modificações em elementos do software são necessárias somente em um lugar e não requerem alterações em outros não relacionados. Além disso, elementos logicamente relacionados tendem a sofrer mudanças de maneira previsível e uniforme.\nOutro ponto importante é que a aplicação do DRY não se limita apenas ao código produzido para sistemas. Ele pode ser aplicado em nível arquitetural, na modelagem de banco de dados, na documentação, em testes unitários\u0026hellip;, ou seja, o conceito é abrangente o suficiente para ser aplicado em todos os estágios do desenvolvimento de software.\nComo surge a duplicação? No livro, são indicados alguns casos onde a inserção de código duplicado é mais recorrente:\nDuplicação imposta: os desenvolvedores acham que não têm escolha – o ambiente parece pedir a duplicação. Duplicação inadvertida: Os desenvolvedores não percebem que estão duplicando informações. Duplicação impaciente: Os desenvolvedores ficam com preguiça e duplicam porque parece mais fácil. Duplicação entre desenvolvedores: Várias pessoas de uma equipe (ou de equipes diferentes) duplicam um bloco de informações. As práticas de duplicação descritas aqui, opostas ao princípio DRY, são categorizadas como WET, podendo ser We Enjoy Typing, We Edit Too much, Write Everything Twice, entre outros.\nÉ interessante como esses acrônimos conseguem representar no mundo real exatamente o que propõem, sendo:\nDRY (seco): Don’t repeat yourself (Não se repita) WET (molhado): We enjoy typing (Nós gostamos de escrever) Como identificar uma violação do DRY? A forma mais clara de identificar uma possível violação do princípio é no momento em que você aplica um ctrl+c + ctrl+v. Este simples ato pode representar a necessidade de aprimoramento estrutural em seu código.\nOutro caso é quando uma alteração na regra de negócio faz com que seja necessário alterar o código em mais de um lugar. A violação fica evidente uma vez que a representação em código da regra não é única e livre de ambiguidades. E deveria ser.\nHá violação do DRY também relacionada à escrita de comentários no código, já que cada vez que seu código precisa ser alterado, seu comentário também precisará, gerando assim trabalho redobrado sempre.\nConclusão Vimos como o DRY pode ser utilizado para evitar situações onde blocos de código executam conceitualmente a mesma função. Nelas, sempre que uma alteração é solicitada, diversos lugares do código devem ser alterados, aumentando a probabilidade de inserção de bugs e tempo gasto com desenvolvimento.\nEsse conceito pode ser aplicado em qualquer escala, do nível mais baixo (código) até os níveis mais altos, evitando a construção de aplicações inteiras duplicadas.\nA busca por soluções genéricas que evitam a duplicação de trabalho, desencadeou a criação de ferramentas mais inteligentes, como linguagens de programação mais avançadas, Padrões de projeto, recursos avançados de manipulação de código, arquiteturas mais sofisticadas, etc.\nPor isso, após muito tempo de reflexão, acredito ser, na minha opinião, o conceito mais importante na programação.\nReferências Don\u0026rsquo;t repeat yourself on Wikipedia Don\u0026rsquo;t repeat yourself on WikiWikiWeb ","date":"2017-01-06T18:28:05Z","permalink":"https://joaolucasgtr.github.io/posts/2017/01/06/o-princ%C3%ADpio-dry/","title":"O princípio DRY"},{"content":"O padrão MVC, que significa Model-View-Controller (Modelo-Visão-Controlador), é um Design Pattern criado para aprimorar o desenvolvimento de interfaces de comunicação com o usuário.\nFoi uma das primeiras abordagens a descrever o conceito de separação de responsabilidades, onde cada letra da sigla representa um componente que possui apenas uma responsabilidade bem definida.\nRelações entre os componentes:\nModelo: é o componente que representa os dados da aplicação. Possui a responsabilidade de gerenciá-los e validá-los, de acordo com regras de negócio; Visão: é a representação gráfica dos dados manipulados pela aplicação. Sua única responsabilidade é a de feedback ao usuário; Controlador: situa-se entre os outros dois componentes, permitindo que os mesmos se comuniquem durante a execução da aplicação. Após a divisão da aplicação nestes três componentes, é esperado que eles se comuniquem da seguinte maneira:\nO modelo gerencia os dados da aplicação recebendo inputs do controlador; A visão exibe os dados presentes em seu modelo; O controlador recebe os inputs do usuário e os direciona para o modelo. Vantagens Algumas das vantagens obtidas ao se aplicar o padrão MVC são:\nAlta coesão: a separação de componentes proposta pelo MVC permite o agrupamento de códigos similares de forma lógica; Baixo acoplamento: a própria natureza do padrão é reduzir o nível de acoplamento entre Modelo, Visão e Controladores; Facilidade de manutenção: em consequência da separação de responsabilidades torna o desenvolvimento futuro mais simples de ser compreendido; Testabilidade: com baixo acoplamento e separação de responsabilidades, cada componente pode ser testado de forma independente. Desvantagens Apesar de ser um padrão extremamente popular e utilizado, ele também possui algumas desvantagens:\nNavegabilidade: a navegação pode se tornar complexa e requer que os desenvolvedores se adaptem à decomposição que o padrão exige; Consistência de vários artefatos: a decomposição em três componentes pode causar dispersão, exigindo maior cuidado dos desenvolvedores para que a consistência seja mantida; Inflação de arquivos: à medida que o projeto cresce, a quantidade de arquivos também crescerá, podendo dificultar a navegação entre eles; Time to market: por exigir conhecimento mais avançado, o início do projeto será mais demorado até que a equipe inteira assimile as exigências do padrão. Como funciona Imagine que nos seja solicitado a implementação de um formulário de cadastro de clientes, e que após algum tempo de análise, chegamos à conclusão que será melhor aplicar o padrão MVC, baseado nas vantagens e desvantagens que ele possui.\nUm bom começo seria a classe de Modelo:\n1 2 3 4 5 6 public class Client { private String name; private String email; /* getters and setters... */ } A visão representa o GUI propriamente dito. No nosso caso, será o terminal:\n1 2 3 4 5 6 7 public class ClientView { public void printClientDetails(String name, String email) { System.out.println(\u0026#34;- Client:\u0026#34;); System.out.println(\u0026#34; Name\u0026#34; + name); System.out.println(\u0026#34; E-mail\u0026#34; + email); } } O controlador recebe as instâncias do modelo e visão, e possui os métodos de manipulação de ambas as classes:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public class ClientController { private Client model; private ClientView view; /* getter and setters... */ public String getClientName() { model.getName(); } public void setClientName(String name) { model.setName(name); } public String getClientEmail() { model.getEmail(); } public void setClientEmail(String email) { model.setEmail(email); } public void updateView() { view.printClientDetails(model.getName(), model.getEmail()); } } No método principal, demonstramos a utilização do padrão:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public static void main(String[] args) { /* create a Client instance: */ Client client = new Client(\u0026#34;John Doe\u0026#34;, \u0026#34;john_doe@email.com\u0026#34;); /* create a View instance: */ ClientView view = new ClientView(); /* create a Controller instance: */ ClientController controller = new ClientController(model, view); controller.updateView(); /* console: - Client: Name: John Doe E-mail: john_doe@email.com */ controller.setClientName(\u0026#34;John moe\u0026#34;); controller.setClientEmail(\u0026#34;john_moe@email.com\u0026#34;); controller.updateView(); /* console: - Client: Name: John Moe E-mail: john_moe@email.com */ } Pode parecer muito trabalho para algo simples e realmente é. Porém, se o objetivo for criar um projeto grande, com diversas interfaces, este padrão irá ajudar a manter a base de código estruturada de forma mais coesa e com com melhor índice de manutenibilidade.\nObservações É extremamente comum encontrar materiais descrevendo o padrão MVC como sendo um padrão arquitetural e isso é um erro. MVC é um padrão de projeto e é frequentemente confundido com arquitetura em camadas.\nUm exemplo claro desse equívoco é encontrado em tutoriais que inserem códigos de acesso ao banco de dados em classes de Modelo. O MVC é um padrão destinado à criação de interfaces, o que numa arquitetura multi camadas significa a camada de apresentação.\nMisturar códigos de camadas diferentes certamente irá gerar efeitos contrários aos propostos: aumento na complexidade do código, falta de coesão, alto acoplamento, etc.\nReferências Model-view-controller on Wikipedia Martin Fowler about GUI Architectures ","date":"2016-12-06T22:22:37Z","permalink":"https://joaolucasgtr.github.io/posts/2016/12/06/o-padr%C3%A3o-mvc/","title":"O padrão MVC"},{"content":"Na engenharia de software, um design pattern (ou padrão de projeto), é uma solução de alto nível já definida para problemas recorrentes no campo da programação. Não representa um framework, código fonte ou algo do tipo, mas sim um template que descreve como deverá ser aplicado para solucionar o problema a que se propõe.\nMas a explosão de popularidade ocorreu mesmo após o lançamento do livro Design Patterns: Elements of Reusable Object-Oriented Software (ou Padrões de Projeto: soluções reutilizáveis de software orientado a objetos), de 1994, escrito pela \u0026ldquo;Gang of four\u0026rdquo;: Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides. A edição original traz a definição de vinte e três padrões clássicos e você encontra uma lista resumida no final deste artigo.\nSobre o livro O livro possui duas partes, sendo a primeira explorando as capacidades e armadilhas da programação orientada a objetos, e a segunda abordando os vinte e três padrões. Para aproveitar a leitura é necessário que você já possua proficiência nos conceitos de orientação a objetos, para que você não tenha que interromper a leitura sempre que for mencionado algo como polimorfismo, herança ou interface, por exemplo.\nPor outro lado, não será uma leitura técnica avançada, pois os padrões são descritos com soluções simples e elegantes, visando suprir algumas necessidades da programação orientada a objetos. Sendo assim, não são necessários recursos incomuns ou truques fantásticos de programação para implementá-los, ou seja, todos os padrões podem ser escritos usando recursos básicos das linguagens de programação.\nBenefícios Assim que entender como utilizar os padrões e sua reação for um \u0026ldquo;A-Ha!\u0026rdquo; (e não um \u0026ldquo;Ahn?\u0026rdquo;), provavelmente nunca mais verá a orientação a objetos da mesma forma. Você terá diversos insights que o ajudarão a produzir designs mais flexíveis, modulares, reutilizáveis e mais compreensíveis. Afinal, este é o seu objetivo, certo?\nConstruir software é difícil, construir software orientado a objetos de forma reutilizável é ainda mais difícil. Você deve criar objetos pertinentes, classes com a granularidade correta, definir boas interfaces e suas heranças, e ainda estabelecer relacionamento entre essas entidades. Você deve evitar o redesign ou ao menos tentar minimizá-lo. Desenvolvedores experientes lhe dirão que um design flexível e reutilizável é praticamente impossível de se fazer da forma \u0026ldquo;certa\u0026rdquo; da primeira vez.\nO propósito do livro é registrar experiências adquiridas anteriormente, transformando-as em padrões, que facilitam a criação de novos sistemas, expressando técnicas bem sucedidas.\nPadrões te ajudam a ter mais alternativas de soluções na hora de escrever código e ainda facilitam o processo de documentação e manutenção, fornecendo especificações explícitas de classes e interação entre os objetos.\nDefinindo um padrão Cada padrão sistematicamente nomeia, explica e avalia um design importante e recorrente. O objetivo é capturar o design de forma que pessoas possam utilizá-lo de forma eficiente.\nEm geral, um padrão possui quatro elementos essenciais:\nNome - O nome do padrão é utilizado para descrever um problema, a solução e as consequências, e deve ser escrito em uma palavra ou duas. Também ajuda na comunicação em um nível alto de abstração e foi um dos pontos mais difíceis durante a produção do livro. Problema a ser resolvido - O problema descreve quando aplicar o padrão e seu contexto. Algumas vezes o problema irá incluir uma lista de condições que devem ser atendidas antes de aplicar o padrão. Solução dada pelo padrão - A solução descreve os elementos que constituem o design, seus relacionamentos, responsabilidades e colaborações. A solução não descreve um design concreto e particular, uma vez que os padrões são templates abstratos para serem aplicados em diversas situações diferentes. Consequências - As consequências são os resultados e os trade-offs da aplicação do padrão e devem sempre ser consideradas antes de decidir a aplicação do padrão. Como escolher um Design Pattern Com mais de vinte padrões no catálogo, pode parecer difícil encontrar um que seja adequado ao seu problema de design. A seguir, algumas abordagens diferentes para definir qual padrão é a melhor escolha para o seu problema:\nConsidere como padrões resolvem problemas de design, quais são os objetos apropriados, a granularidade desses objetos e interfaces relacionadas. Estudar estes pontos é um bom ponto de partida para encontrar um padrão adequado. Leia através de cada intenção dos padrões para encontrar um ou mais que pareçam relevantes para o seu problema. Utilize o catálogo no próximo tópico para facilitar sua busca. Estude como os padrões se relacionam. Estudar os relacionamentos podem te guiar na direção certa dos padrões ou grupos de padrões. Imagem de referência no final do artigo. Estude os padrões por seu propósito. Existem três categorias diferentes de padrões: criacionais, estruturais e comportamentais. Isto com certeza irá facilitar a busca ao comparar padrões diferentes agrupados por propósito. Examine as causas de redesign, pois elas possuem padrões relacionados criados para resolver estes problemas. Considere o que pode ser variável no seu design. Em vez de considerar o que poderia forçá-lo ao redesign, considere o que quer que seja possível mudar sem redesign. O foco aqui está em encapsular o conceito que irá variar, tema de muitos padrões. Lista de padrões por categoria Criacionais São padrões que criam objetos, em vez de ter que instanciá-los diretamente. Isto proporciona ao programa maior flexibilidade em decidir quais objetos precisam ser criados para um determinado caso.\nAbstract factory agrupa factories que possuem um tema em comum. Builder constrói objetos complexos separando construção e representação. Factory Method constrói objetos sem especificar exatamente qual classe utilizar. Prototype cria objetos clonando outros existentes. Singleton restringe a criação de um objeto para uma única instância de classe. Estruturais Estes visam composição de objetos e classes. Utilizam herança para compor interfaces e definir maneiras de compor objetos e obter novas funcionalidades.\nAdapter permite classes com interfaces incompatíveis a trabalharem juntas, criando sua própria interface a partir de uma classe já existente. Bridge desacopla abstração de implementação para que as duas possam variar independentemente. Composite compõe zero ou mais objetos similares, para que possam ser manipulados como um só. Decorator dinamicamente adicionar ou sobrescreve o comportamento de um método já existente em um objeto. Facade provê uma interface simplificada para uma implementação grande de código. Flyweight reduz o custo de criação e manipulação de um grande número de objetos parecidos. Proxy provê uma forma para que outro objeto controle o acesso, reduza custos e reduza a complexidade. Comportamentais A maioria destes padrões se preocupa com a comunicação entre objetos.\nChain of responsibility delega comandos para uma cadeia de processamento de objetos. Command cria objetos que encapsulam ações e parâmetros. Interpreter implementa uma linguagem especializada. Iterator acessa os elementos de uma coleção sem expor sua representação interna. Mediator permite desacoplamento entre classes, sendo a única a ter conhecimento detalhado de seus métodos. Memento provê habilidade de restaurar um objeto ao seu estado anterior (ctrl+z). Observer permite comunicação entre objetos através de eventos. State permite um objeto a mudar seu comportamento quando seu estado interno altera. Strategy permite escolher dinamicamente um algoritmo, de uma família, em tempo de execução. Template define um algoritmo esqueleto como uma classe abstrata, permitindo que subclasses implementem o comportamento concreto. Visitor separa um algoritmo de uma estrutura de objeto ao mover-se hierarquicamente dentre métodos de um objeto. Por onde começar? Se você ainda não é um desenvolvedor com experiência, então comece com os mais simples e comuns, listados a seguir:\nAbstract Factory Adapter Composite Decorator Factory Method Observer Strategy Template Method Conclusão A importância dos padrões de projetos é reconhecida globalmente por oferecer soluções inteligentes para problemas recorrentes. Dificilmente você encontrará sistemas orientados a objetos que não utilizem ao menos um dos padrões apresentados neste artigo, sendo que em sistemas grandes a tendendência é que vários padrões tenham sido utilizados.\nAplicar padrões de projetos é considerada uma boa prática de engenharia de software pois evita que você viole o princípio DRY (don\u0026rsquo;t repeat yourself), ao poupar a si mesmo de gastar horas pensando em soluções que já foram criadas, aplicadas e testadas em ambientes de produção ao redor do globo.\n","date":"2016-12-01T20:44:42Z","permalink":"https://joaolucasgtr.github.io/posts/2016/12/01/sobre-padr%C3%B5es-de-projeto/","title":"Sobre padrões de projeto"},{"content":"Se você é um desenvolvedor de software que almeja aperfeiçoar sua técnica de escrita de código (sim, existem técnicas para escrever código), então você provavelmente irá se deparar com diversos princípios de programação criados pela Engenharia de Software. Estes princípios foram criados com o intuito de aprimorar alguns atributos de qualidade de sistemas, que apesar de não funcionais influenciam diretamente no resultado final de um produto de software.\nBenefícios Ao aplicar os princípios você estará automaticamente sendo beneficiado nos atributos:\nReadability (Leitura) - O código será mais facilmente entendido por outros membros do time de desenvolvimento. Modularity (Modularidade) - A divisão de funcionalidades em peças independentes (módulos) facilitará o processo de reuso e reduzirá a quantidade final de código escrito para a aplicação. Maintainability (Manutenabilidade) - O processo de manutenção será beneficiado com a melhoria da qualidade do código, além disso será diminuída a barreira de entrada de novos desenvolvedores nos projetos. Extensibility (Extensibilidade) - A inclusão de novas funcionalidades no sistema reduzirá consideravelmente a chance de efeitos colaterais devido ao código desacoplado. Agility (Agilidade) - Em decorrência da otimização dos processos de desenvolvimento, manutenção e extensão, os clientes poderão receber software de maneira mais ágil. Sobre os princípios A lista a seguir contém apenas alguns princípios chave, que serão o suficiente para começar e observar o aprimoramento na qualidade de código produzido instantaneamente. A lista completa de artigos no Wikipedia você encontra aqui:\nWikipedia\u0026rsquo;s programming principles articles list. KISS A sigla KISS é o acrônimo para \u0026ldquo;keep it simple, stupid\u0026rdquo; ou \u0026ldquo;keep it stupid simple\u0026rdquo;. Este princípio visa reduzir casos de Overengineering, ou excesso de engenharia, que é muito comum entre desenvolvedores do nível júnior e pleno.\nO foco principal é a simplicidade, evitando ao máximo toda complexidade desnecessária. Uma tática para aplicação do princípio é sempre quebrar grandes problemas em problemas menores, mais simples e mais compreensíveis.\nYAGNI You aren\u0026rsquo;t gonna need it (você não vai precisar disso) sugere aos desenvolvedores que não seja adicionado qualquer recurso ao software antes que ele seja realmente necessário. Segundo o princípio, o código deve se restringir aos requisitos já existentes e não em tentar prever solicitações futuras.\nEste conceito foi proposto pela metodologia Extreme Programming de desenvolvimento ágil, que visa atacar a satisfação do cliente, pois em vez de entregar tudo que o cliente poderia desejar no futuro, será entregue somente o que ele precisa para hoje.\nSeparation of concerns Separation of concerns (separação de responsabilidades) é um princípio que visa separar o código em partes distintas, organizadas de forma lógica de acordo com sua responsabilidade. A aplicação correta deste princípio irá resultar em um grau maior de desacoplamento, tornando o software modular, onde cada módulo encapsula todo código relacionado à sua responsabilidade de forma lógica e coesa.\nO princípio se aplica também à Arquitetura de Software, e foi utilizado como base para as definições de arquiteturas em camadas, por exemplo.\nSOLID A sigla SOLID, em desenvolvimento de software, representa cinco princípios de design que visam facilitar a compreensão, desenvolvimento e manutenção de sistemas orientados a objetos. Aplicar o SOLID na prática significa aprimorar drasticamente a qualidade do código, tornando-o mais: legível, coeso, testável e reutilizável.\nConceitos:\nSigla Nome Descrição S Single-responsibility principle Uma classe deveria possuir somente uma responsabilidade e razão para mudar. O Open–closed principle Entidades do software devem estar abertas à extensão mas fechadas para modificação L Liskov substitution principle Objetos em um programa devem poder ser substituídos por instâncias dos seus subtipos sem alterar seu funcionamento. I Interface segregation principle Muitas interfaces específicas são melhores que uma interface generalista. D Dependency inversion principle É melhor depender de abstrações e não de implementações. Claramente, aplicar o SOLID em 100% do código que você escreve é uma tarefa extremamente difícil, e será ainda mais caso você fique adiando o dia de botar a mão na massa e aplicar os conceitos.\nBoy-Scout Rule Os escoteiros possuem uma regra bem simples e clara:\n“Leave Things BETTER than you found them.” - Robert Baden Powell\nAo acampar, se o local de acampamento estiver uma bagunça, você deve limpá-lo independentemente de quem bagunçou, sempre deixando-o mais limpo do que estava quando você chegou.\nEntão Robert C. Martin adaptou essa regra para a programação, dizendo:\n\u0026ldquo;Leave the code cleaner than you found it\u0026rdquo; - Robert C. Martin\n\u0026ldquo;Deixe o código mais limpo do que estava quando você o encontrou\u0026rdquo;, significa sempre que possível aplicar refatorações de melhoria nos códigos, isso irá contribuir para a qualidade do projeto em geral e evitar a deterioração natural que os sistemas tendem a seguir durante seu período de vida.\nO artigo de refatoração oportunista, de Martin Fowler, segue a mesma linha de raciocínio.\nDRY Don\u0026rsquo;t repeat yourself (Não se repita) é o último, mas não menos importante, princípio desta lista. O princípio define que \u0026ldquo;cada porção de conhecimento em um sistema deve possuir uma representação ÚNICA em todo o sistema\u0026rdquo;.\nUtilizar o DRY significa trabalhar de forma mais inteligente, escrevendo menos código e produzindo valor no software de forma mais rápida ao reutilizar fragmentos genéricos.\nExiste uma técnica bem simples para identificar possíveis violações do DRY: se você usou crtl+c + crtl+v em algum momento no seu código, é bem provável que você o esteja violando.\nViolações do princípio são chamadas de soluções WET (lol), que podem significar: write every time, write everything twice, we enjoy typing, etc.\nConclusão Existem diversos outros princípios para desenvolvimento de software importantes, meu objetivo aqui foi somente trazer alguns para discussão e servir de guia para futuras pesquisas sobre o assunto.\n","date":"2016-10-06T14:39:31Z","permalink":"https://joaolucasgtr.github.io/posts/2016/10/06/princ%C3%ADpios-importantes/","title":"Princípios Importantes"},{"content":"Este artigo possui um compilado de dicas importantes para você que quer criar um site para seu negócio, ou refazê-lo, de forma a modernizar a imagem da sua empresa.\nComponentes vitais A página inicial é responsável pela primeira impressão, ela deve explicar quem você é, o que faz e o que os visitantes podem fazer no site. Design simples vencerá sobre páginas repletas de componentes.\nPontos de comunicação Para alguns modelos de negócio, apenas a visita do cliente não significa nada. Então, o negócio deveria conter ao menos um ponto de conversão da visita em valor.\nExemplo: Campo para cadastro de e-mail.\nE-mails cadastrados indicam clientes em alto potencial, porém seria necessário também um sistema de envio de informações, oportunidades e ofertas.\nAções de conversão claras Converter visitantes em clientes é o objetivo. Logo, é necessário oferecer ações limpas e específicas que guiarão o visitante através do site até o local de vendas. Para isso, é importante manter o visitante certo do que está fazendo.\nExemplos:\nAssinar Ver mais Comprar Compartilhe com seus amigos Download, etc\u0026hellip; Página \u0026ldquo;Sobre\u0026rdquo; A página \u0026ldquo;Sobre\u0026rdquo; é geralmente a página mais visitada do site. Fazê-la mais pessoal e contar alguma história são sugestões. Um jeito efetivo de contar uma história seria explicar como e por quê decidiu iniciar esse tipo de negócio.\nExemplos:\nApresentação pessoal: (Olá, meu nome é \u0026hellip;) Apresentar um problema pelo qual já passou: (Quando quis desenvolver meu primeiro site, não tinha ideia de onde começar\u0026hellip;) Identificação com cliente: (Todos nós já passamos por esse problema antes e é extremamente frustrante\u0026hellip;) Descrição da volta por cima: (Então percebi que não precisava ser difícil. Descobri que poderia desenvolver meu site com\u0026hellip;) Explicação do valor ímpar da sua proposta: (\u0026hellip;utilizando métodos que tornam a criação de sites em um processo mais acessível e prazeroso.) Introdução da situação atual do negócio: (Agora, temos uma equipe de 25 colaboradores trabalhando com dúzias de empreendedores, ajudando-os a criar lindos websites) Missão: (Ajudar o máximo de pessoas a tirarem seus sonhos do papel) Depoimentos De acordo com uma pesquisa da BrightLocal, 88% dos clientes dizem que confiam em depoimentos online tanto quanto em recomendações pessoais. A mesma pesquisa afirma que:\n\u0026ldquo;aproximadamente 9 em cada 10 clientes olharam análises online para tomar decisões de compras nos últimos 12 meses\u0026rdquo;.\nGoogle Analytics A utilização deste serviço ajudará a responder às seguintes perguntas:\nQuantas pessoas visitaram meu site? Quanto tempo gastaram visualizando meu site? Quantos visitantes eram novos? Onde encontraram meu site? Quais páginas são mais visitadas no meu site? Qual a última página visualizada antes de saírem? Definições antes de iniciar o projeto Antes de iniciar o projeto, considere os seguintes tópicos.\nJuntar informações vitais do seu Business Seu webdesigner será muito mais efetivo e eficiente se puder prover as informações vitais sobre o seu negócio no começo do projeto, economizando tempo (dinheiro) sem a necessidade de revisitar tarefas anteriores para adicionar informações esquecidas.\nDefinir:\nLista de páginas necessárias; Lista de explicações dos serviços e benefícios de cada um, ilustradas com fotos, descrições, preços, missão\u0026hellip; Lista de formas de contato bem localizadas na página; Ordem de prioridade sobre informações no site. Criação de logo de alta resolução Definir um logo que realmente representa a marca para utilização de mesmo padrão de estilo no site.\nUtilização de fotos profissionais Conteúdo visual é processado 60.000 vezes mais rápido do que texto. Por isso é extremamente recomendado a utilização de boas imagens condizentes com o tom da marca. O ideal seriam fotos reais da localização da empresa, construindo assim conexões mais fortes entre o negócio e o cliente.\nCompilação de ideias de acordo com o seu gosto Se deseja um produto que te agrade, deixe o desenvolvedor saber o que você gosta antes do começo do desenvolvimento. Levante outros sites e anote detalhes que contenham elementos que atraiam o seu gosto, como por exemplo:\nFonte; Esquema de cores; Layout; Imagens, etc. Referência Bright Local, Pesquisa de 2014 ","date":"2016-06-21T20:35:12Z","permalink":"https://joaolucasgtr.github.io/posts/2016/06/21/features-essenciais-para-sites-%C3%BAteis/","title":"Features essenciais para sites úteis"},{"content":"SemVer.org 2.0.0\nSumário Dado um número de versão [MAJOR].[MINOR].[PATCH], incremente a:\nversão Maior (MAJOR): quando fizer mudanças incompatíveis na API, versão Menor (MINOR): quando adicionar funcionalidades mantendo compatibilidade, e versão de Correção (PATCH): quando corrigir falhas mantendo compatibilidade. Especificação (SemVer) palavras-chave definidas aqui.\n(\u0026hellip;)\nUm número de versão normal DEVE ter o formato de X.Y.Z, onde X, Y, e Z são inteiros não negativos, e NÃO DEVE conter zeros à esquerda. X é a versão Maior, Y é a versão Menor, e Z é a versão de Correção. Cada elemento DEVE aumentar numericamente. Por exemplo: 1.9.0 -\u0026gt; 1.10.0 -\u0026gt; 1.11.0.\nUma vez que um pacote versionado foi lançado (released), o conteúdo desta versão NÃO DEVE ser modificado. Qualquer modificação DEVE ser lançado como uma nova versão.\nVersão de Correção Z (x.y.Z | x \u0026gt; 0) DEVE ser incrementado apenas se mantiver compatibilidade e introduzir correção de bugs. Uma correção de bug é definida como uma mudança interna que corrige um comportamento incorreto.\nVersão Menor Y (x.Y.z | x \u0026gt; 0) DEVE ser incrementada se uma funcionalidade nova e compatível for introduzida na API pública. DEVE ser incrementada se qualquer funcionalidade da API pública for definida como descontinuada. PODE ser incrementada se uma nova funcionalidade ou melhoria substancial for introduzida dentro do código privado. PODE incluir mudanças a nível de correção. A versão de Correção deve ser redefinida para 0(zero) quando a versão Menor for incrementada.\nVersão Maior X (X.y.z | X \u0026gt; 0) DEVE ser incrementada se forem introduzidas mudanças incompatíveis na API pública. PODE incluir alterações a nível de versão Menor e de versão de Correção. Versão de Correção e Versão Menor devem ser redefinidas para 0(zero) quando a versão Maior for incrementada.\nPor que usar Versionamento Semântico? Sem a aderência a algum tipo de especificação formal, os números de versão são essencialmente inúteis para gerenciamento de dependências.\nDando um nome e definições claras às ideias acima, fica fácil comunicar suas intenções aos usuários de seu software.\nExemplo:\nConsidere uma biblioteca chamada CaminhaoBombeiros; Ela requer um pacote versionado dinamicamente chamado Escada; Quando CaminhaoBombeiros foi criado, Escada estava na versão 3.1.0; Como CaminhaoBombeiros utiliza algumas funcionalidades que foram inicialmente introduzidas na versão 3.1.0, você pode especificar, com segurança, a dependência da Escada como maior ou igual a 3.1.0 porém menor que 4.0.0; Agora, quando Escada versão 3.1.1 e 3.2.0 estiverem disponíveis, você poderá lançá-los ao seu sistema de gerenciamento de pacote e saberá que eles serão compatíveis com os softwares dependentes existentes. Como um desenvolvedor responsável você irá querer certificar-se que qualquer atualização no pacote funcionará como anunciado. O que você pode fazer é deixar o Versionamento Semântico lhe fornecer uma maneira sensata de lançar e atualizar pacotes sem precisar atualizar para novas versões de pacotes dependentes, salvando-lhe tempo e aborrecimento.\nFAQ Consultas, perguntas e respostas sobre o Versionamento Semântico.\nFAQ\nSobre A Especificação da Semântica de Versionamento é autoria de Tom Preston-Werner, criador do Gravatars e co-fundador do GitHub.\nPalavras chave para utilização em RFC\u0026rsquo;s para indicar níveis de requisitos RFCs - Request For Comments\nDEVE: Esta palavra, ou os termos OBRIGATÓRIO e DEVERÁ, significam que a definição é um requisito absoluto da especificação;\nNÃO DEVE: Esta frase, ou os termos NÃO DEVERÁ, significam que a definição é um proibição absoluta da especificação;\nPODEM: Esta palavra, ou o adjetivo RECOMENDADO, significam que podem existir motivos válidos para ignorar um item em particular, mas as implicações completas devem ser entendidas e cuidadosamente pesadas antes de escolher seguir um curso diferente;\nNÃO PODEM: Esta frase, ou a frase NÃO RECOMENDADO, significam que podem existir motivos válidos onde o comportamento particular é aceitável ou até útil, mas as implicações completas devem ser entendidas e cuidadosamente pesadas antes de implementar um comportamento descrito com este rótulo.\n","date":"2016-05-04T13:49:11Z","permalink":"https://joaolucasgtr.github.io/posts/2016/05/04/introdu%C3%A7%C3%A3o-ao-versionamento-sem%C3%A2ntico/","title":"Introdução ao versionamento semântico"},{"content":"As estórias de usuário, ou User Stories, são utilizadas para organização de requisitos por parte do PO (Product Owner) e tem como foco principal o objetivo do usuário.\nEstórias fracionam os requisitos e facilitam a estimação do esforço gasto para realização do objetivo descrito, sendo curtas, simples e claras. Caso uma estória acabe ficando extensa, isso é um sinal de que ela pode ser divida em outras.\nPrincípio INVEST O acrônimo INVEST foi criado para definir as características de uma boa estória, como demonstrado a seguir:\nLetra Significado Resumo I Independent Uma boa estória deve ser independente de outras. N Negotiable Até o dia da implementação, a estória pode ser modificada ou reescrita. V Valuable Deve entregar algum valor para o usuário final. E Estimable O prazo para entrega deve sempre ser estimável. S Small Não deve demorar mais do que um Sprint para ser entregue. T Testable Se não puder testar as alterações entregues, não saberá se funcionam bem, certo? Definições e exemplos Para construir uma estória, basta definir o autor, a ação,a funcionalidade desejada, ou seja, o resultado, e a sua prioridade.\nAutor - O proprietário da estória, a pessoa interessada na funcionalidade. Recomendado descrição de forma bem clara.\nAção - A ação necessária para que o autor possa alcançar seu objetivo.\nResultado - Resultado que ator espera ao executar a ação, de acordo com sua ótica.\nPrioridade - Estórias com prioridade alta serão incluídas mais cedo nos Sprint\u0026rsquo;s.\nModelo:\nComo um [autor], eu quero [ação] para que [resultado]. Prioridade: [alta, média, baixa]. Exemplo de um sistema de biblioteca:\nComo um \u0026quot;vendedor responsável pelo setor de livros\u0026quot;, eu quero \u0026quot;procurar por livros filtrando por nome\u0026quot;, para que possa \u0026quot;verificar se o livro x está disponível\u0026quot;. Prioridade: \u0026quot;alta\u0026quot;. Exemplo de sistema de aluguel de filmes:\nComo um \u0026quot;cliente\u0026quot;, eu quero \u0026quot;ver os filmes disponíveis para locação\u0026quot;, para que possa \u0026quot;alugá-lo\u0026quot;. Prioridade: \u0026quot;alta\u0026quot;. Exemplo de sistema de cadastro de clientes\nComo um \u0026quot;vendedor\u0026quot;, eu quero \u0026quot;consultar meus clientes pelo CNPJ\u0026quot;, para \u0026quot;negociar descontos para pessoa jurídica\u0026quot;. Prioridade: \u0026quot;média\u0026quot;. ","date":"2016-03-08T23:58:59Z","permalink":"https://joaolucasgtr.github.io/posts/2016/03/08/guia-pr%C3%A1tico-para-cria%C3%A7%C3%A3o-de-user-stories/","title":"Guia prático para criação de User Stories"},{"content":"A tabela abaixo foi criada para demonstrar alguns tipos de teste, que constituem o conceito de Software testing.\nO objetivo é prover uma visão geral sobre diferentes possibilidades de análise do Software, a fim de encontrar falhas e determinar a qualidade do mesmo.\nTeste Resumo Referência Installation testing O teste de instalação se concentra nos requisitos necessários para que o cliente possa executar corretamente o Software. Wiki Compatibility testing O teste de compatibilidade é conduzido à aplicação, a fim de avaliar a compatibilidade do Software com ambiente presente no cliente. Wiki Smoke Testing Teste orientado ao \u0026ldquo;Coração\u0026rdquo; do sistema. Verificação na funcionalidade principal do Software. Wiki Regression Testing O teste de regressão procura descobrir novos Bugs após alterações feitas no código, incluindo a re-execução de testes efetuados anteriormente à mudança, para comparação com resultados oriundos dos testes atuais. Wiki Acceptance testing Teste formal, respeitando as necessidades do cliente, requisitos e regras de negócio, para determinar se o Software satisfaz, ou não, os critérios acordados com o cliente. Wiki Alpha testing Ver referência Wiki Beta testing Ver referência Wiki Continuous testing Teste contínuo é o processo de execução de Testes Automatizados, a fim de obter resultados imediatos referentes aos riscos de negócio associados ao Software Release Candidate. Wiki Destructive testing Teste destrutivo é a tentativa de fazer com que o Software falhe, passando Inputs com valores inválidos e, ou, inesperados. Wiki Performance testing Aplicado para determinar como o Software se comporta, em termos de responsividade e estabilidade, para que sejam investigados fragmentos de código onde possam ser aplicadas melhorias na implementação, design e arquitetura. Wiki Usability testing Utilizado para determinar se as interfaces do usuário são fáceis de usar e compreender. Wiki Acessibility testing Teste de acessibilidade é aplicado para verificar as diretrizes de usabilidade, determinadas no início do projeto. Wiki Security testing Teste essencial para Software\u0026rsquo;s que processam dados confidenciais, a fim de evitar invasões. Wiki Internationalization and localization Teste para identificar se há erros na adaptação de tradução do aplicativo para outras linguagens. Wiki Development testing Testes aplicados em sincronia com o processo de desenvolvimento, visando diminuir os riscos, tempo e custo do Software. Wiki A/B testing Basicamente, consiste em comparar duas saídas, quando apenas uma variável foi alterada. Ex: execute um teste, mude alguma variável, execute o teste novamente, compare os resultados. Wiki Concurrent testing O foco é comparar o desempenho em baterias de teste com rotinas e entradas normais em oposição ao teste com valores não esperados, como o stress testing ,por exemplo. Wiki Conformance testing Teste funcional, caixa-preta, no qual uma implementação é testada com relação aos requisitos mencionados explicitamente na sua especificação. Wiki ","date":"2015-11-09T17:53:41Z","permalink":"https://joaolucasgtr.github.io/posts/2015/11/09/tipos-de-teste/","title":"Tipos de teste"},{"content":"\nO Ciclo de vida para liberação de um software consiste na soma dos estágios de desenvolvimento e amadurecimento para um fragmento de Software: abrangendo desde o seu desenvolvimento inicial até o seu lançamento, incluindo versões atualizadas que aplicam melhorias ou correções no Software.\nOs estágios são:\nPré-alfa (Pre-alpha) Pré-alfa se refere à todas as atividades realizadas no projeto do Software, antes de ser testado, que podem ser: Análise de requisitos, Design do Software, Testes unitários, etc.\nAlfa (Alpha) A fase alfa é a primeira onde se iniciam os testes do Software. Nela, são aplicadas algumas técnicas de teste, como a Caixa Branca. Validações adicionais são utilizadas por outra equipe, usando técnicas de Caixa Cinza e Caixa Preta.\nO Software alfa pode ser instável, contendo Bugs e perda de dados, e pode não contar com todos os recursos planejados anteriormente.\nBeta (Beta) A fase beta, geralmente, começa quando o Software está com os recursos completos, porém ainda suscetível à Bugs, problemas de performance e perda de dados.\nO foco desta fase é reduzir os impactos ao usuário, aplicando testes de usabilidade.\nGeralmente, é nesta fase onde os produtos estarão disponíveis do lado de fora da empresa que os desenvolveu, sendo utilizados em demonstrações, por exemplo.\nCandidato à Liberação (Release Candidate) Nessa fase, o Software está em uma versão beta, mas com potencial para se tornar um produto final. Todos os recursos já foram planejados, implementados e testados sem reportar algum Bug significativo.\nAinda poderá haver alteração no código para consertar defeitos, mudanças na documentação e arquivos, e código externos para casos de teste.\nOs testadores receberão essa versão para utilizá-la como produto final e a conduzirão para clientes, onde serão efetuados testes a partir de suas perspectivas.\nLiberação ao Mercado (Release to Marketing) O produto está pronto para ser entregue para os clientes, contendo uma assinatura digital que garanta sua autenticidade.\nPode significar também, em outro contexto, que o Software já foi entregue para um cliente para instalação em seu respectivo Hardware de usuário final. O termo não define o mecanismo de entrega, mas apenas o estado de qualidade, que é suficiente para distribuição em massa.\nDisponibilidade Geral (General Availability) Disponibilidade Geral é o estágio onde todas as atividades de comercialização necessárias já foram completadas e o produto está disponível no mercado.\nAtividades de comercialização podem incluir testes de compilação e segurança, assim como localização e disponibilidade em escala global.\nO tempo entre Liberação ao Mercado e Disponibilidade Geral pode durar de uma semana a meses, em caso de atraso nas atividades de comercialização.\nGold O termo Gold se refere à versão mais atual do Software e pode incluir alguns Patches, ou até mesmo pacotes de serviços, que os usuários das versões Liberação ao Mercado e Disponibilidade Geral teriam que baixar individualmente.\nPode incluir também alguns recursos extras ou Addons criados após as liberações anteriores.\n","date":"2015-11-06T08:24:41Z","permalink":"https://joaolucasgtr.github.io/posts/2015/11/06/est%C3%A1gios-para-libera%C3%A7%C3%A3o-de-software/","title":"Estágios para liberação de software"},{"content":"O FHS, ou (File Hierarchy Standard - padrão hierárquico de arquivos), define os principais diretórios para sistemas operacionais Linux ou baseados em Unix. O que difere bastante do padrão utilizado pelo Windows, onde cada partição do disco rígido recebe uma letra para representá-lo, e pastas do sistema possuem nomes específicos de acordo com seu conteúdo.\nNo FHS, são utilizadas palavras abreviadas, a maioria contendo três letras, o que pode causar estranheza num primeiro contato e dificultar o entendimento do propósito do diretório.\nOs principais são:\n\u0026ldquo;/\u0026rdquo; - A raíz Tudo no Linux está localizado abaixo do diretório /, conhecido como diretório raiz. Mesmo ao montar outras partições, estas estarão abaixo do diretório raiz, diferente do Windows, onde outra partição seria montada no caminho D: provavelmente.\n/bin - Binários essenciais Neste diretório estão mantidos todos os binários essenciais para utilização por parte de um usuário. Programas como bash (sh), copy (cp), VI (vi), Process Status (ps), entre outros\u0026hellip;, estão mantidos aqui. Colocar binários neste diretório garante que o sistema terá esses utilitários mesmo que outros diretórios não sejam montados.\nO diretório /sbin funciona da mesma maneira, porém contendo utilitários essenciais para administração do sistema. Exemplos: adduser, fdisk, iptables, reboot, etc.\n/sbin – Binários de administração Contém binários de forma similar ao diretório /bin, porém os que estão contidos aqui foram criados com a intenção de serem executados por usuários com privilégios de administrador do sistema.\n/boot – Arquivos de Boot Este diretório contém os arquivos necessários para inicialização do sistema. Por exemplo, os arquivos da ferramenta GRUB e os kernels estão armazenados aqui.\n/dev – Devices Distribuições Linux expõem dispositivos como arquivos neste diretório. Embora não sejam realmente arquivos, são exibidos como tal, por exemplo sda é exibido como um arquivo mas representa o primeiro drive SATA no sistema.\nAqui também são mantidos pseudo-dispositivos que não representam de verdade um hardware, como por exemplo o /dev/null, que representa um dispositivo especial que não produz dados de saída e nem de entrada, sendo útil para o caso onde é necessário descartar a saída de programas, bastando utilizar o pipe para este dispositivo.\n/etc – Arquivos de configuração Diretório responsável por manter arquivos de configuração do sistema como um todo. Configurações pessoais de um usuário devem ser mantidos em seu respectivo diretório /home.\n/home - Lar Contém os diretórios base de cada usuário criado no sistema e é responsável por manter os dados deste usuário, além de seu arquivos específicos de configuração. Caso um usuário queira alterar dados na pasta /home de outro, é necessário obter privilégios de administrador.\n/lib – Bibliotecas essenciais Aqui estão mantidas as bibliotecas (libraries) essenciais para os programas contidos nos diretórios /bin e /sbin.\n/lost+found – Arquivos recuperados Diretório de \u0026ldquo;achados e perdidos\u0026rdquo;. Caso o sistema quebre, uma checagem de arquivos será realizada no próximo boot e quaisquer arquivos corrompidos serão colocados neste diretório para que seja possível analisar e recuperar dados destes arquivos.\n/media – Mídia removível Responsável por criar sub-diretórios correspondentes à dispositivos de mídia removível conectados ao computador.\n/mnt – Pontos de montagem Por convenção, é utilizado para montar temporariamente outros discos disponíveis ou partições. Porém, esta operação é possível de ser feita em qualquer outro diretório.\n/opt – Pacotes opcionais Contém sub-diretórios para pacotes de software opcionais. É comumente utilizada por softwares de terceiros e proprietários.\n/proc – Processos Contém diretórios virtuais que representam os processos em execução no sistema. Cada diretório é nomeado de acordo com o ID do processo e quando o mesmo é encerrado, automaticamente seu diretório irá desaparecer.\n/root – Root home Este é o diretório home do usuário root. Como este usuário é diferente dos demais, seu diretório base não fica localizado em /home/root mas apenas em /root.\n/run – Estado de aplicações Este diretório fornece um local padrão para as aplicações armazenarem dados sobre seu estado que não podem ser armazenadas no diretório /tmp, uma vez que estando lá, os dados poderão ser descartados em algum momento.\n/tmp – Temporários As aplicações irão armazenar neste diretórios arquivos temporários. Geralmente, estes arquivos serão apagados ao reiniciar o sistema e podem ser deletados ao executar algum utilitário de limpeza do sistema.\n/usr – Binários de usuários O diretório /usr contém aplicações e arquivos utilizados por usuários de forma isolada do resto do sistema. Por exemplo, aplicações que não são essenciais estarão mantidas em /usr/bin e não em /bin. Comandos que necessitam de privélgio de administrador estarão em /usr/sbin e não em /sbin. Bibliotecas necessárias para estes programas estarão em /usr/lib.\n/var – Arquivos variáveis O diretório /var contém arquivos que podem ser alterados por aplicações, durante o tempo de execução. Um exemplo claro é o sub-diretório /var/log, que mantém os logs de execução de aplicações e do sistema operacional.\nPara visualizar a documentação completa, acesse: FHS-3.0\n","date":"2015-08-10T14:17:50Z","permalink":"https://joaolucasgtr.github.io/posts/2015/08/10/estrutura-de-diret%C3%B3rios-linux/","title":"Estrutura de diretórios Linux"},{"content":"Markdown é uma linguagem de marcação leve com sintaxe de texto puro. Seu design permite que seja convertida para muitos formatos, incluindo .html, .pdf, .docx, entre outros.\nO propósito principal por trás do Markdown é fazer com que o texto seja o mais limpo e legível possível, não contendo tags ou instruções de formatação, ou seja, com Markdown você escreve tendo o foco principal no conteúdo e não em código.\nEmbora criado há bastante tempo, em 2004, o Markdown é uma prova de futuro (Future proof), pois simplesmente representa texto simples, ao contrário de outras maneiras de escrita WYSIWYG.\nSendo simplesmente texto, você está livre para usar qualquer editor simples para utilizá-lo, diferentemente do Microsoft Word, por exemplo, que possui mais de 10 tipos diferentes de extensão para escrita.\nPor que utilizar? Devido a sua simplicidade de escrita e interpretação, sua adoção foi massiva e tornou-se uma espécie de padrão, não oficial, para escrita de documentações e aplicativos de chat.\nO Github utiliza o Markdown com alguns recursos extras em seu site para simplificar a escrita de Issues ou arquivos README; Trello na escrita de seus populares cards; Slack para formatação de mensagens; além de diversas ferramentas para geração de sites estáticos que adotaram a escrita em Markdown como padrão de publicação de conteúdo.\nA propósito, todo o conteúdo deste blog é escrito utlizando Markdown. =)\nReferências Daring Fireball, by John Gruber; Github Flavored Markdown Markdown on Wikipedia Exemplos A seguir, alguns exemplos básicos para demonstração da marcação:\nTítulos: 1 2 3 4 5 6 # h1 Heading ## h2 Heading ### h3 Heading #### h4 Heading ##### h5 Heading ###### h6 Heading h1 Heading h2 Heading h3 Heading h4 Heading h5 Heading h6 Heading Ênfase: 1 2 3 4 5 6 7 8 9 **Este texto está em negrito** __Este texto está em negrito__ *Este texto está em itálico* _Este texto está em itálico_ ~~RASURADO~~ Este texto está em negrito\nEste texto está em negrito\nEste texto está em itálico\nEste texto está em itálico\nRASURADO\nBlockquotes: 1 2 3 \u0026gt; Blockquotes também podem ser aninhados... \u0026gt;\u0026gt; ...utilizando outro sinal de **maior que**... \u0026gt; \u0026gt; \u0026gt; ...ou com espaço entre os sinais. Blockquotes também podem ser aninhados\u0026hellip;\n\u0026hellip;utilizando outro sinal de maior que\u0026hellip;\n\u0026hellip;ou com espaço entre os sinais.\nListas: Não ordenadas:\n1 2 3 4 5 6 7 + Crie listas iniciando a linha com `+`, `-`, or `*` + Sub-listas são feitas indentando por 2 espaços: - Alterar o caractere de marcação força a criação de nova lista: * Ac tristique libero volutpat at + Facilisis in pretium nisl aliquet - Nulla volutpat aliquam velit + Simples! Crie listas iniciando a linha com +, -, or * Sub-listas são feitas indentando por 2 espaços: Alterar o caractere de marcação força a criação de nova lista: Ac tristique libero volutpat at Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Simples! Ordenadas:\n1 2 3 4 5 6 1. Lorem ipsum dolor sit amet 2. Consectetur adipiscing elit 3. Integer molestie lorem at massa 4. Você pode usar números sequenciais... 5. ...ou manter todos os números como `1.` Lorem ipsum dolor sit amet\nConsectetur adipiscing elit\nInteger molestie lorem at massa\nVocê pode usar números sequenciais\u0026hellip;\n\u0026hellip;ou manter todos os números como 1.\nCódigo: 1 Código em `linha` Código em linha\n1 2 3 4 5 6 Código indentado: // comentários... linha 1 de código linha 2 de código linha 3 de código Código indentado:\n// comentários... linha 1 de código linha 2 de código linha 3 de código Links: 1 [link com texto](http://joaolucasgtr.gitlab.io/) link com texto\n1 [link com título](http://joaolucasgtr.gitlab.io/ \u0026#34;texto do título!\u0026#34;) link com título\nImagens: 1 2 ![Minion](https://octodex.github.com/images/minion.png) ![Stormtroopocat](https://octodex.github.com/images/stormtroopocat.jpg \u0026#34;The Stormtroopocat\u0026#34;) \u0026hellip;para a especificação completa de recursos, visite os links referenciados.\n","date":"2015-03-04T11:52:32Z","permalink":"https://joaolucasgtr.github.io/posts/2015/03/04/o-que-%C3%A9-markdown/","title":"O que é Markdown?"},{"content":"Utilizar o Terminal de comandos pode parecer uma tarefa complexa, limitada e intimidadora para usuários não ambientados. Porém, com a enorme adoção de sistemas operacionais Linux por parte de servidores, e Mac por desenvolvedores, é necessário pelo menos um pouco de familiaridade com a ferramenta.\nAlém disso, a maioria das linguagens e frameworks disponibilizam seus recursos por meio de CLI, que significa Command Line Interface (interface de linha de comando), mesma prática adotada por ferramentas de outras áreas como banco de dados e sistemas de controle de versão.\nExemplos:\nnodejs (node e npm) emberjs e angular php ruby python git e svn mysql e postgres \u0026hellip;entre outras.\nOu seja, é praticamente impossível pensar num ambiente de desenvolvimento que não necessite de nenhuma interação com a linha de comando.\nE com o passar do tempo é provável que você adquira mais habilidade e produtividade utilizando ferramentas do Terminal.\nCatálogo A seguir, um catálogo simplificado para servir como ponto de partida para adaptação à linha de comando de sistemas baseados em Unix, por categoria.\nNavegação pwd: imprime o caminho completo do diretório atual. ls [path]: lista os arquivos publicos informados no parâmetro path. cd [path]: navegar para o diretório informado no parâmetro path. Ajuda man [command]: exibe o manual do comando informado no parâmetro command. [command] --help ou [command] -h: geralmente, ferramentas da linha de comando irão exibir um menu de opções disponíveis e informações de utilização do comando informado no parâmetro command. Manipulação de arquivos cp [source] [destination]: copiar o arquivo informado no parâmetro source para o caminho no parâmetro destination. mv [source] [destination]: mover arquivo ou pasta do parâmetro source para o caminho informado em destination, ou renomear caso o destino seja o mesmo diretório. touch [filename]: cria um arquivo com o nome informado no parâmetro filename. mkdir [fullpath]: cria um diretório com o caminho completo informado no parâmetro fullpath. rm [filename]: excluir o arquivo informado no parâmetro filename. rm -r [path]: exclui um diretório informado no parâmetro path. ln -s [source] [destination]: cria um link simbólico entre o arquivo informado no parâmetro source e o destino informado no destination. Visualização de arquivos echo [text]: imprime o texto informado no parâmetro text no terminal. echo $[varname]: exibe o conteúdo presente na variável informada no parâmetro varname. cat [filename]: imprime o conteúdo presente no arquivo informado no parâmetro filename. head [filename]: imprime as dez primeiras linhas do arquivo informado no parâmetro filename. tail [filename]: imprime as dez últimas linhas do arquivo informado no parâmetro filename. grep [pattern] [filename]: imprime as linhas do arquivo informado no parâmetro filename que satisfazem o padrão (Regex) informado no parâmetro pattern. Administração sudo [command]: executa o comando informado no parâmetro command como super usuário. [command1] \u0026amp;\u0026amp; [command2]: o operador \u0026amp;\u0026amp; permite que vários comandos sejam executados em sequência. [command] \u0026amp;: executa o comando informado no parâmetro command em segundo plano. bash [script.sh]: utiliza o bash para executar o script informado no parâmetro script.sh. [command1] | [command2]: redireciona a saída do comando command1 para a entrada do comando command2. [command] \u0026gt; [filename]: redireciona a saída do comando command1 para um arquivo criado com o nome informado em filename. [command] \u0026gt;\u0026gt; [filename]: adiciona a saída do comando command1 no final do arquivo informado no parâmetro filename. Processos ps: exibe uma lista de processos em execução do usuário atual no terminal atual. ps -e: exibe todos os processos em execução. pstree: exibe a lista de processos em execução, em forma de árvore. pgrep [name]: exibe o PID do processo informado no parâmetro name. kill -9 [PID]: envia o sinal de encerramento para o processo que possui o PID informado no parâmetro PID. Permissões chmod [code] [filename]: altera a permissão do arquivo informado em filename de acordo com o código informado no parâmetro code. chmod +x [filename]: torna o arquivo filename um executável. chwon [path]: altera o dono do arquivo ou diretório informado no parâmetro path. Commando \u0026ldquo;find\u0026rdquo; find .: procura arquivos e diretórios recursivamente a partir do atual. find . -name *.png -exec cp '{}' ~/images \\;: copia todos os arquivos PNG para a pasta ~/images. find . -name .svn -prune -exec rm -r '{}' \\;: exclui todos os diretórios com nome .svn. find . -type f -exec file '{}' \\;: executa os arquivos. Net ssh user@server: acessar um servidor via SSH. scp user@host:[remotefile] [localpath]: Copia o arquivo remoto para uma pasta local. scp [localfile] user@host:[remotepath]: Copia um arquivo local para o servidor remoto. wget [url]: efetua o download do arquivo informado em url a partir da web. ","date":"2015-03-03T14:00:18Z","permalink":"https://joaolucasgtr.github.io/posts/2015/03/03/guia-b%C3%A1sico-de-comandos-do-terminal/","title":"Guia básico de comandos do Terminal"},{"content":"Primeiramente introduzido por Roy Fielding em sua dissertação de mestrado de 2000, o termo REST representa um estilo arquitetural focado na troca de dados entre clientes e servidores pela web. Note que o termo correto para definição de REST é estilo arquitetural, não é um protocolo e nem um padrão de projeto.\nO ponto chave é que o servidor não precisa saber nada sobre a aplicação em si, deixando-o altamente desacoplado e facilmente integrável por clientes diversos.\nO termo REST é um acrônimo para Representational State Transfer (Transferência de Estado Representacional), porém o legal é que a palavra REST significa descansar, que é exatamente o comportamento de uma api REST.\nPrincípios No capítulo cinco, Roy descreve os princípios básicos de sua tese, que são:\nClient-Server (Cliente-Servidor) - Aplicações REST possuem arquitetura Cliente-Servidor, obedecendo o conceito de Separação de responsabilidades. Isto facilita o processo de evolução, portabilidade e escalabilidade de software. Stateless (Sem estado) - O servidor não deve manter nenhum estado a respeito dos clientes. Cada requisição deve conter toda informação necessária para entendimento e processamento da mesma. Cache - Para aprimorar a eficiência da rede, servidores podem marcar respostas como cacheable (cacheáveis), para que os clientes possam reutilizá-las posteriormente. Uniform Interface (Interface uniforme) - A característica central que difere o REST de outras arquiteturas web é sua ênfase em uma interface uniforme de comunicação. Layered System (Sistema em camadas) - Compor a aplicação em camadas, onde cada componente não consegue acessar código presente fora de sua camada, facilita a adição de balanceadores de carga e proxies, para aprimorar a performance e segurança. Um serviço é dito RESTful quando atende aos princípios descritos acima, definidos por Roy. A combinação destes princípios criam um tipo de aplicação bem específico, focado em escalabilidade, performance e segurança.\nProtocolo O protocolo utilizado para comunicação é o HTTP. Apesar de existir há mais de vinte anos, o protocolo recebeu diversas atualizações para modernização e aprimoramento semântico. Sugestões de criação de novos verbos, pelo próprio Roy, foram adotadas e implementadas, permitindo que a leitura ficasse bem mais próxima da nossa realidade. Requisições como:\nGET - http://server:8080/users DELETE - http://server:8080/users/john POST - http://server:8080/users - data={ name: stevie } são extremamente explícitas no que se propõem a fazer.\nREST vs RESTful Após a definição do que é REST e RESTful, pode ser que ainda exista dúvida sobre as diferenças entre os termos. Sabemos que REST é um estilo arquitetural e RESTful é o serviço que implementa REST. Porém, somente pode-se dizer que uma api é RESTful se a mesma obedecer a todos os princípios definidos por Roy.\nMuitos desenvolvedores podem não sentir nenhum tipo de incômodo ao se deparar com endpoints como estes:\nGET - http://server:8080/users/123/delete PUT - http://server:8080/users Tudo bem se você consegue viver com isso, rs. Estes endpoints não estão errados, a nível de código, e irão funcionar normalmente sem lançamento de exceções ou algo do tipo. Porém, eles não respeitam a questão semântica do estilo arquitetural, visto que, no primeiro caso, um verbo GET está sendo usado para deleção, e no segundo, PUT usado para criação.\nDica Para aprimorar a habilidade de criação de endpoints semânticos, basta imaginar sua api como uma estrutura de diretórios.\nConsiderando a entidade Usuario, imagine que você possui uma pasta chamada Usuarios, criada dentro do diretório Sistema. Dentro desta pasta, existem várias pastas, uma para cada usuário do sistema, onde cada nome de pasta seja equivalente ao Id do respectivo usuário. Em cada pasta de usuário, estaria um arquivo de texto com os dados do mesmo.\n1 2 3 4 5 6 7 8 9 10 _ Usuarios | |_ 1 | |_ usuario_1.txt | |_ 2 | |_ usuario_2.txt | |_ 3 |_ usuario_3.txt Navegando pelo gerenciador de arquivos do seu sistema operacional, abrir a pasta de Usuarios lhe exibirá a lista de Ids de usuários do sistema. Consequentemente, abrir a pasta de um usuário mostrará suas informações. O \u0026ldquo;endereço\u0026rdquo; de navegação entre arquivos seria:\n/Sistema, para mostrar a pasta de usuários; /Usuarios, para exibir os Ids; /Usuarios/1, para ler informações de um usuário. Caso queira excluir um usuário, basta excluir a pasta do seu Id; Para atualizar, incluir um novo arquivo na sua pasta de Id; e para criar, basta adicionar uma nova pasta dentro do diretório Usuarios.\nAgora, basta utilizar a mesma ideia para criar endpoints para todos os verbos HTTP. Exemplo:\nVerbo Recurso Descricao GET /usuarios Retorna a lista de usuários do sistema GET /usuarios/:id Retorna dados do usuário pelo seu Id informado POST /usuarios Envia um novo usuário para ser inserido no sistema, no corpo da requisição PUT /usuarios/:id Envia dados para atualização do usuário, de acordo com seu Id informado DELETE /usuarios/:id Exclui do sistema o usuário pelo seu Id informado Conclusão A discussão sobre REST vs RESTful na realidade é uma discussão desnecessária. Cabe ao time decidir se haverá regras tão formais sobre a criação de apis ou mais maleáveis. O importante é manter a consistência através do código para evitar falhas de interpretação e divergências entre os membros.\nReferência Roy Fielding Paper - Chapter 5 ","date":"2015-02-26T16:53:33Z","permalink":"https://joaolucasgtr.github.io/posts/2015/02/26/sobre-rest-e-restful/","title":"Sobre REST e RESTful"},{"content":"Revisado em 01/2016\nEste documento tem como objetivo exemplificar duas maneiras distintas de se aplicar paginação utilizando o MSSQL Server.\nObjetivo:\nReproduzir as operações de paginação corretas, de acordo com a tabela a seguir:\nLimite Página 1 Página 2 Página 3 20 de 1 até 20 de 21 até 40 de 41 até 60 30 de 1 até 30 de 31 até 60 de 61 até 90 Onde Limite é a quantidade de itens exibidos por página.\nCalculando número de linhas Sintaxe:\n1 2 3 4 5 6 7 SELECT * FROM ( SELECT ROW_NUMBER() OVER ( /* [ordenação] */ ) AS Linha , * FROM /* [tabela] */ ) AS Linhas WHERE Linha \u0026gt;= /* [linha inicial] */ AND Linha \u0026lt;= /* [linha final] */ Desta maneira, o número atual da linha é retornado como uma coluna na tabela de resultados obtidos da sub-query. Isso permite a utilização dessa coluna para limitar os índices de início e fim dos resultados desejados.\nPorém, utilizando essa abordagem, ainda é necessária a implementação de lógica para determinar esses valores, como demonstrado a seguir:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 DECLARE @pagina1 INT = 3 , @limite1 INT = 20 DECLARE @linha_inicial AS INT , @linha_final AS INT IF @pagina1 \u0026lt;\u0026gt; 1 BEGIN SET @linha_inicial = ((@pagina1 - 1) * @limite1) + 1 END ELSE BEGIN SET @linha_inicial = @pagina1 END SET @linha_final = @limite1 * @pagina1 SELECT @linha_inicial AS inicio, @linha_final AS fim Exemplo:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /* - Tratando e obtendo valores para os índices; - Obtendo um resultado paginado da tabela de usuários ordenados pelo Id de forma decrescente; */ DECLARE @pagina1 INT = 3 , @limite1 INT = 20 DECLARE @linha_inicial AS INT , @linha_final AS INT IF @pagina1 \u0026lt;\u0026gt; 1 BEGIN SET @linha_inicial = ((@pagina1 - 1) * @limite1) + 1 END ELSE BEGIN SET @linha_inicial = @pagina1 END SET @linha_final = @limite1 * @pagina1 SELECT * FROM ( SELECT ROW_NUMBER() OVER (ORDER BY Id DESC) AS Linha , * FROM Usuario ) AS Linhas WHERE Linha \u0026gt;= @linha_inicial AND Linha \u0026lt;= @linha_final Uma \u0026ldquo;nova\u0026rdquo; abordagem A \u0026ldquo;nova\u0026rdquo; abordagem se assemelha aos recursos já presentes em outros SGBDs há mais tempo, como MySql ou Postgres, onde é necessário apenas a utilização de um valor para o OFFSET (índice inicial de obtenção dos resultados) e LIMIT (quantidade de resultados obtidos por página).\nSintaxe:\n1 2 3 4 5 SELECT * FROM /* [tabela] */ /* ordenação */ OFFSET /* offset */ ROWS FETCH NEXT /* limit */ ROWS ONLY Embora ainda seja necessária a utilização de lógica para obtenção dos valores de OFFSET e LIMIT, a sintaxe dessa abordagem é muito mais limpa e intuitiva, otimizando o tempo gasto em futuras refatorações.\nPorém, esse recurso só está disponível na versão 12 ou posteriores do MSSQL.\nExemplo:\nA seguir, uma implementação do exemplo dado anteriormente utilizando a nova sintaxe.\n1 2 3 4 5 6 7 8 DECLARE @pagina2 INT = 3 , @limite2 INT = 20 SELECT * FROM Usuario ORDER BY ErpId DESC OFFSET @limite2 * (@pagina2 - 1) ROWS FETCH NEXT @limite2 ROWS ONLY Conclusão Os resultados obtidos nas duas queries de exemplo são equivalentes, exceto pelo fato de que na abordagem utilizando ROW_NUMBER() o número da linha é retornado como uma coluna extra na tabela de resultados.\n","date":"0001-01-01T00:00:00Z","permalink":"https://joaolucasgtr.github.io/posts/1/01/01/como-paginar-resultados-no-mssql/","title":"Como paginar resultados no MSSQL"}]